{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/ma2104/cauchy-schwarz-inequality","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"cauchy-schwarz-inequality\"\n  }, \"Cauchy-Schwarz Inequality\"), mdx(\"p\", null, \"For any $\\\\vec u, \\\\vec v \\\\in \\\\R^n$,\"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\n\\\\vec u \\\\cdot \\\\vec v &\\\\leq |\\\\vec u||\\\\vec v| \", \"\\\\\", \"\\n\\\\text{i.e. } (\\\\vec{u} \\\\cdot \\\\vec v)^2 &\\\\leq (\\\\vec u \\\\cdot \\\\vec u) (\\\\vec v \\\\cdot \\\\vec v)\\n\\\\end{aligned}\\n$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"If $\\\\vec u = \\\\vec 0 \\\\in \\\\R^n$, then LHS = 0 = RHS.\"), mdx(\"p\", null, \"Assume $\\\\vec u \\\\neq \\\\vec 0$. Consider the quadratic polynomial\"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\n&(\\\\vec u \\\\cdot \\\\vec u)x^2 + 2(\\\\vec u \\\\cdot \\\\vec v)x + (\\\\vec{v} \\\\cdot \\\\vec{v}) \", \"\\\\\", \"\\n&= (\\\\sum^n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{i = 1} {u_i}^2) x^2 + (2 \\\\sum^n\"), \"{i = 1} {u\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i} v_i) x + (\\\\sum^n\"), \"{i = 1} {v\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i}^2) \", \"\\\\\", \"\\n&= \\\\sum^n\"), \"{i = 1} (u_i x + v_i)^2 \", \"\\\\\", \"\\n& \\\\Rightarrow \\\\text{discriminant of polynomial is } \\\\leq 0 \", \"\\\\\", \"\\n&\\\\therefore 4(\\\\vec u \\\\cdot \\\\vec v)^2 - 4(\\\\vec u \\\\cdot \\\\vec{u})(\\\\vec{v} \\\\cdot \\\\vec{v}) \\\\leq 0 \", \"\\\\\", \"\\n&\\\\therefore (\\\\vec{u} \\\\cdot \\\\vec v)^2 \\\\leq (\\\\vec u \\\\cdot \\\\vec u) (\\\\vec v \\\\cdot \\\\vec v)\\n\\\\end{aligned}\\n$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"lengths-and-angles\"\n  }, \"Lengths and Angles\"), mdx(\"h2\", {\n    \"id\": \"dot-product\"\n  }, \"Dot Product\"), mdx(\"p\", null, \"Dot product as per the classical definition.\"), mdx(\"h3\", {\n    \"id\": \"length\"\n  }, \"Length\"), mdx(\"p\", null, \"If $u \\\\in \\\\R^3$, then the length of $u$ is \"), mdx(\"p\", null, \"$$\\\\vert u \\\\vert = \\\\sqrt{u \\\\cdot u}$$\"), mdx(\"h3\", {\n    \"id\": \"angle\"\n  }, \"Angle\"), mdx(\"p\", null, \"If $u \\\\neq 0$ and $v \\\\neq 0$, then the angle between $u$ and $v$ is defined as \"), mdx(\"p\", null, \"$$\\\\cos (\\\\theta) = \\\\frac{u \\\\cdot v}{\\\\vert u \\\\vert \\\\vert v \\\\vert}$$\"), mdx(\"h3\", {\n    \"id\": \"property-of-dot-products\"\n  }, \"Property of Dot products\"), mdx(\"p\", null, \"The standard dot product clearly satisfies these conditions\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$u \\\\cdot u \\\\geq 0 \\\\forall u \\\\in \\\\R^n$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$u \\\\cdot u = 0 \\\\leftrightarrow u = 0$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$u \\\\cdot v = v \\\\cdot u, \\\\forall u, v \\\\in \\\\R^n$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It is linear in both \\\"slots\\\"\")), mdx(\"h2\", {\n    \"id\": \"bilinear-forms\"\n  }, \"Bilinear Forms\"), mdx(\"p\", null, \"Recall that a dual vector is a mapping that takes in a vector and returns a scalar.\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"bilinear form\"), \" on a finite-dimension vector space $V$ is a mapping $g$ from $V \\\\times V$ to $\\\\R$ which is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"linear\"), \" in both slots, that is,\\nif $u, v, w \\\\in V$ and $a, b \\\\in \\\\R$, then  \"), mdx(\"p\", null, \"$$g(au + bv, w) = ag(u, w) + bg(v, w)$$\\n$$g(w, au + bv) = ag(w, u) + bg(w, v)$$\"), mdx(\"h3\", {\n    \"id\": \"fact\"\n  }, \"Fact\"), mdx(\"p\", null, \"The set of bilinear forms $\\\\mathbf{B}(V)$, is a vector space.\"), mdx(\"p\", null, \"So if $g, h \\\\in \\\\mathbf{B}(V)$, then\"), mdx(\"p\", null, \"$$(g + h)(u, v) = g(u, v) + h(u, v)$$\"), mdx(\"h3\", {\n    \"id\": \"tensor-product-of-dual-vectors\"\n  }, \"Tensor Product of Dual Vectors\"), mdx(\"p\", null, \"Let $\\\\alpha, \\\\beta \\\\in \\\\hat V$, and let $u, v$ be any vectors in $V$.\\nThen the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"tensor product\"), \" of $\\\\alpha$ with $\\\\beta$, is the element of $\\\\mathbf{B}(V)$,\"), mdx(\"p\", null, \"$$\\\\alpha \\\\otimes \\\\beta (u, v) = \\\\alpha(u) \\\\beta(v)$$\"), mdx(\"p\", null, \"Now let $z_i$ be a basis for $V$, and let $\\\\zeta^j$ be the dual basis.\"), mdx(\"p\", null, \"For each pair of indices $(i, j)$, $\\\\zeta^i \\\\otimes \\\\zeta^j$ is a bilinear form.\"), mdx(\"h3\", {\n    \"id\": \"basis-for-bilinear-forms\"\n  }, \"Basis for Bilinear Forms\"), mdx(\"p\", null, \"Any bilinear form on $V$ can be expressed as in the form $g_{ij} \\\\zeta^i \\\\otimes \\\\zeta^j$.\"), mdx(\"p\", null, \"The full set $\\\\zeta^i \\\\otimes \\\\zeta^j$ (with $i, j$ taking all possible values) is a basis for $\\\\mathbf{B}(V)$.\"), mdx(\"p\", null, \"To see this, let $g$ be any bilinear form on $V$ and think about $g(z_i, z_j)$.\"), mdx(\"p\", null, \"Any bilinear form on $V$ can be expressed  in the form $g\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{ij} \\\\zeta^i \\\\otimes \\\\zeta^j$.\\nThe numbers $g\"), \"{ij}$ are called the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"components\"), \" of $g$ relative to the basis $z_i$.\"), mdx(\"h3\", {\n    \"id\": \"convention\"\n  }, \"Convention\"), mdx(\"p\", null, \"We can arrange the components of a bilinear form into a matrix.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"441px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/efc6e/2021-04-07-15-42-30.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"50%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABPUlEQVQoz5VS2YqDQBDM//9SQETy4AUSYkAlPgSJCBGPXB4x6WwVtJjdpy0Yp9vpo6pnVvKD9/s9r//g9XqJ5uu+UqcoCnk8HjIMgzyfzzmo6zqZpokL/3A+jiPPLpeLlGX5VXSFT9/3kqYpd9M0JQxDNgAMw5DdbsdzMPJ9X7bbLVfTNHI4HGa2ZKid4jjmAVi2bctdGcJHjDa/Xq/0YUdR9C0ZBgK0YFVVlKUzRTEdg8bebjeOANKRB/tPwSRJSHu9Xstms5Hj8cggy7I4hiAI6LuuS99xHLnf78yDCr2gWTKoK9BJA5bz+Q0wRN7ytllQOwFgdj6fKRM4nU70IR2Anec5/WWejmh+NlmWSV3XYtu2eJ7HQgBs/Nvv90zA7UIudsSj+NezUQP09X1Bgg4a0He4HAEWVCwvBOsDibn/TUEWlXcAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"2021 04 07 15 42 30\",\n    \"title\": \"2021 04 07 15 42 30\",\n    \"src\": \"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/efc6e/2021-04-07-15-42-30.png\",\n    \"srcSet\": [\"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/0d3e1/2021-04-07-15-42-30.png 140w\", \"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/6b1e2/2021-04-07-15-42-30.png 281w\", \"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/efc6e/2021-04-07-15-42-30.png 441w\"],\n    \"sizes\": \"(max-width: 441px) 100vw, 441px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"This is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"matrix of the bilinear form relative to the basis\"), \" $z_i$.\"), mdx(\"h1\", {\n    \"id\": \"inner-product\"\n  }, \"Inner Product\"), mdx(\"p\", null, \"An \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"inner product space\"), \" is a pair $(V, g)$ consisting of a vector space $V$ and a bilinear form $g$, called an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"inner product\"), \" on $V$, with the following properties\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, u) \\\\geq 0 \\\\; \\\\forall u \\\\in V$ (positivity)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, u) = 0$ iff $u = 0$. (definiteness)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, v) = g(v, u) \\\\; \\\\forall u, v \\\\in V$ (symmetry)\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$g$ is not unique. We choose a $V$ we want to study, then select a $g$.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Set of inner products on $V$ is not a subspace\"), mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Zero \\\"vector\\\" does not satisfy definiteness\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Negative scalar of an inner product does not satisfy positivity.\"))), mdx(\"h2\", {\n    \"id\": \"length-and-angles-again\"\n  }, \"Length and Angles again\"), mdx(\"p\", null, \"Let $(V, g)$ be an inner product space.\\nThe \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"length\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"norm\"), \" of a vector $v \\\\in V$ is defined\"), mdx(\"p\", null, \"$$\\\\vert v \\\\vert  = \\\\sqrt{g(v, v)}$$\"), mdx(\"p\", null, \"where the square root is the non negative one.\"), mdx(\"hr\", null), mdx(\"p\", null, \"Vectors $u, v \\\\in V$ are said to be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"orthogonal\"), \" if $g(u, v) = 0$.\"), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"orthogonal-decomposition\"\n  }, \"Orthogonal Decomposition\"), mdx(\"p\", null, \"Any vector in an inner product space can be written as\"), mdx(\"p\", null, \"$$u = \\\\frac{g(u, v)}{\\\\vert u \\\\vert^2} + \\\\Bigg ( u - \\\\frac{g(u, v)}{\\\\vert v \\\\vert^2} v \\\\Bigg )$$\"), mdx(\"p\", null, \"where $v$ is any non-zero vector.\"), mdx(\"h2\", {\n    \"id\": \"cauchy-schwarz-inequality\"\n  }, \"Cauchy-Schwarz Inequality\"), mdx(\"p\", null, \"If $u, v \\\\in V$, where $(V, g)$ is an inner product space,\\nthen\"), mdx(\"p\", null, \"$$\\\\vert g(u, v) \\\\vert \\\\leq \\\\vert u \\\\vert \\\\vert v \\\\vert $$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Furthermore, this inequality is only equal if 1 vector is a scalar multiple of another.\")), mdx(\"p\", null, \"Related to [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../ma2104/cauchy-schwarz-inequality\",\n    \"title\": \"Cauchy-Schwarz Inequality\"\n  }, \"cauchy-schwarz-inequality\"), \"] for [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../ma2104/module-ma2104\",\n    \"title\": \"Multivariable Calculus\"\n  }, \"module-ma2104\"), \"].\"), mdx(\"h3\", {\n    \"id\": \"triangle-inequality\"\n  }, \"Triangle Inequality\"), mdx(\"p\", null, \"if $(V, g)$ is an inner product space (so that we can take norm of $v$) and $u, v \\\\in V$, then \"), mdx(\"p\", null, \"$$ \\\\vert u + v \\\\vert \\\\leq \\\\vert u \\\\vert + \\\\vert v \\\\vert$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The inequality is equal iff one vector is a non-negative multiple of the other.\")), mdx(\"h3\", {\n    \"id\": \"angles\"\n  }, \"Angles\"), mdx(\"p\", null, \"Let $(V, g)$ be an inner product space, and let $u, v$ be vectors in $V$.\\nThen the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"angle\"), \" between $u$ and $v$, $\\\\theta$, is defined as the number between $0$ and $\\\\pi$ inclusive that satisfies\"), mdx(\"p\", null, \"$$\\\\cos (\\\\theta) = \\\\frac{g(u, b)}{\\\\vert u \\\\vert \\\\vert v \\\\vert}$$\"), mdx(\"h2\", {\n    \"id\": \"orthonormal-basis\"\n  }, \"Orthonormal Basis\"), mdx(\"p\", null, \"Let $(V, g)$ be an inner product space, and let $z_i$ be a basis.\\nThen $z_i$ is said to be an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"orthonormal\"), \" basis if, for all $i, j$, we have\"), mdx(\"p\", null, \"$$g(z\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i, z_j) = I\"), \"{ij}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The matrix of an inner product, regarded as a bilinear form, relative to an orthonormal basis is the identity matrix.\")), mdx(\"h2\", {\n    \"id\": \"gram-schmidt-orthogonalization\"\n  }, \"Gram-Schmidt Orthogonalization\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Every (finite-dimensional) inner product space has an orthonormal basis.\")), mdx(\"h2\", {\n    \"id\": \"riez-representation\"\n  }, \"Riez Representation\"), mdx(\"p\", null, \"Let $(V, g)$ be an inner product space, and let $u \\\\in V$.\\nDefine a dual vector $\\\\Gamma_u$ by\"), mdx(\"p\", null, \"$$\\\\Gamma_u(v) := g(u, v) \\\\; \\\\forall v \\\\in V$$\"), mdx(\"p\", null, \"Thus the inner product allows us to turn the vector $u$ into a dual vector $\\\\Gamma_u$.\\nThe mapping \"), mdx(\"p\", null, \"$$\\\\Gamma : u \\\\rightarrow \\\\Gamma_u$$\"), mdx(\"p\", null, \"is a mapping from $V$ to $\\\\hat V$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This mapping is an isomorphism\")), mdx(\"h3\", {\n    \"id\": \"riez-representation-theorem\"\n  }, \"Riez Representation Theorem\"), mdx(\"p\", null, \"In an inner product space $(V, g)$, any dual vector $\\\\alpha$ can be expressed as $\\\\Gamma(u)$ for some unique $u \\\\in V$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The matrix $g_{jk}$ can be solved\")), mdx(\"h1\", {\n    \"id\": \"the-complex-case\"\n  }, \"The Complex Case\"), mdx(\"p\", null, \"If $H$ is any complex number, then it has a complex conjugate $\\\\bar H$,\\nand then $H \\\\bar H$ is always real, and always positive.\"), mdx(\"p\", null, \"Take the dot product of $u, v$ to be $u \\\\cdot \\\\bar v$.\\nThat is, the second vector is mapped to its complex conjugate on all components.\"), mdx(\"p\", null, \"This makes the length or norm of a vector, defined as $dot(u, u)$, to always be positive and real.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"You want the length to be real so that you can make statements ordering the length of different vectors\")), mdx(\"p\", null, \"However, this means that the dot product is no longer commutative.\"), mdx(\"p\", null, \"Constants in the second \\\"slot\\\" would also have to be converted to its complex conjugate to bring it out of the bracket.\"), mdx(\"p\", null, \"$$u \\\\cdot (cv) = \\\\bar c u \\\\cdot v$$\"), mdx(\"h2\", {\n    \"id\": \"sesquilinear-form\"\n  }, \"Sesquilinear Form\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sesquilinear form\"), \" on a complex vector space $V$ is a mapping $g$ from $V \\\\times V$ to $\\\\mathcal{C}$ which is linear on the first slot,\\nbut \\\"conjugate-linear\\\" in the second slot.\"), mdx(\"p\", null, \"That is, for any $u, v  \\\\in V, c \\\\in \\\\mathcal{C}$, we have\"), mdx(\"p\", null, \"$$g(cu, v) = cg(u, v)$$\\n$$g(u, cv) = \\\\bar cg(u, v)$$\"), mdx(\"hr\", null), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"complex inner product space\"), \" is a pair $(V, g)$ consisting of a complex vector space $V$ and a sesquilinear form $g$ that satisfies\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, u) \\\\geq 0 \\\\; \\\\forall u \\\\in V$ (positivity)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, u) = 0$ iff $u = 0$ (definiteness)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, v) = \\\\overline{g(v, u)} \\\\; \\\\forall u, v \\\\in V$ (conjugate symmetry)\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Cauchy-Schwarz and Pythagoras and orthogonal decomposition still works the same.\")), mdx(\"h2\", {\n    \"id\": \"riez-representation-theorem-for-complex\"\n  }, \"Riez Representation Theorem for Complex\"), mdx(\"p\", null, \"Define $\\\\Gamma_u(v) := g(v, u)$.\\nThis allows for linearity.\"), mdx(\"p\", null, \"However, $\\\\Gamma : u \\\\rightarrow \\\\Gamma_u$ is not a vector space isomorphism.\"), mdx(\"h3\", {\n    \"id\": \"conjugate-isomorphism\"\n  }, \"Conjugate Isomorphism\"), mdx(\"p\", null, \"Let $V$ and $W$ be complex vector spaces.\\nA \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"conjugate isomorphism\"), \" $F: V \\\\rightarrow W$ is a bijective map that satisfies\"), mdx(\"p\", null, \"$$F(au + bv) = \\\\bar a F(u) + \\\\bar bF(v) \\\\; \\\\forall a, b \\\\in \\\\mathcal{C}, u, v, \\\\in V$$\"), mdx(\"p\", null, \"So $\\\\Gamma$ is a conjugate isomorphism instead of an isomorphism.\"), mdx(\"h2\", {\n    \"id\": \"schurs-theorem\"\n  }, \"Schur's Theorem\"), mdx(\"p\", null, \"Given a linear operator $T$ on a finite-dimensional complex inner product space, there exists an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"orthonormal\"), \" basis with respect to which $T$ has an upper-triangular matrix.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The product of upper-triangular matrices is upper-triangular.\")), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"Over $C$, every linear operator has an upper-triangular matrix with respect to some basis of $V$.\"), mdx(\"p\", null, \"Then it also has an upper-triangular matrix with respect to some orthonormal basis of $V$.\"), mdx(\"h1\", {\n    \"id\": \"spectral-theorem\"\n  }, \"Spectral Theorem\"), mdx(\"p\", null, \"The existence of an inner product on a vector space allows us to think of vectors as dual vectors.\"), mdx(\"p\", null, \"Thinking of linear transformations as bilinear/sesquilinear forms.\"), mdx(\"p\", null, \"Let $T$ be an operator on teh complex inner product space $(V, g)$. Then define a bilinear/sesquilinear form $\\\\tau$ by\"), mdx(\"p\", null, \"$$T(u, v) := g(u, Tv), \\\\forall u, v \\\\in V$$\"), mdx(\"h3\", {\n    \"id\": \"hermitian-symmetric-transformation\"\n  }, \"Hermitian (Symmetric) Transformation\"), mdx(\"p\", null, \"A bilinear/sesquilinearform is said to be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hermitian\"), \"  or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"symmetric\"), \" if for all $u, v \\\\in V$, we have\"), mdx(\"p\", null, \"$$\\\\tau(u, v) = \\\\overline{\\\\tau (v, u)}$$\"), mdx(\"p\", null, \"A linear transformation $T$ on an inner product space is called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hermitian\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"symmetric\"), \" if its corresponding sesquilinear/bilinear form is hermitian/symmetric.\"), mdx(\"p\", null, \"ie, $T$ satisfies\"), mdx(\"p\", null, \"$$g(u, Tv) = \\\\tau(u, v) = \\\\overline{\\\\tau (v, u)} = \\\\overline{g(v, Tu)} = g(Tu, v) \\\\; \\\\forall u, v \\\\in V$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If we use an orthonormal basis, then the matrices of $T$ and $\\\\tau$ are the same.\")), mdx(\"h3\", {\n    \"id\": \"eigenvalues\"\n  }, \"Eigenvalues\"), mdx(\"p\", null, \"The eigenvalues of a symmetric/Hermitian linear transformation are real.\"), mdx(\"h4\", {\n    \"id\": \"proof-1\"\n  }, \"Proof\"), mdx(\"p\", null, \"We have\"), mdx(\"p\", null, \"$$g(u, Tu) = g(u, \\\\lambda u) = \\\\bar \\\\lambda g(u, u)$$\"), mdx(\"p\", null, \"and \"), mdx(\"p\", null, \"$$g(u, Tu) = g(Tu, u) = \\\\lambda g(u, u)$$\"), mdx(\"p\", null, \"Since $g$ is definite and eigenvectors are not the zero vector,\\nwe have $g(u, u) \\\\neq 0$.\"), mdx(\"p\", null, \"So we can divide and conclude that $\\\\bar \\\\lambda = \\\\lambda$.\"), mdx(\"h3\", {\n    \"id\": \"complex-spectral-theorem\"\n  }, \"(Complex) Spectral Theorem\"), mdx(\"p\", null, \"Any Hermitian linear transformation $T$ on a complex inner product space has a real, diagonal matrix relative to some orthonormal basis.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Applies for symmetric linear transformation on real vector spaces.\")), mdx(\"h4\", {\n    \"id\": \"proof-2\"\n  }, \"Proof\"), mdx(\"p\", null, \"First put the matrix of $T$ into upper triangular form with respect to an orthonormal basis;\"), mdx(\"p\", null, \"Since $T$ and $\\\\tau$ are complex conjugates of each other, the associated sesquilinear form is also upper-triangular and is Hermitian.\"), mdx(\"p\", null, \"But those entries are zero, so both the lower and upper triangle are zero.\\nSo the matrix is diagonal.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"70c1bda2-8a7e-570b-a747-7d1949e619e6","fields":{"slug":"/ma2101/lengths-and-angles","title":"Lengths and Angles"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"triangle-inequality\"\n  }, \"Triangle Inequality\"), mdx(\"p\", null, \"Suffices to show \"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\n|\\\\vec u + \\\\vec v|^2 &\\\\leq ( |\\\\vec u||\\\\vec v| )^2 \", \"\\\\\", \"\\n(\\\\vec{u} \\\\cdot \\\\vec v)^2 &\\\\leq |\\\\vec u|^2 + |\\\\vec v|^2 + 2|\\\\vec u||\\\\vec v| \", \"\\\\\", \"\\n\\\\vec u \\\\cdot \\\\vec u + 2 \\\\vec u \\\\cdot \\\\vec v + \\\\vec v \\\\cdot \\\\vec v & \\\\leq |\\\\vec u|^2 + |\\\\vec v|^2 + 2|\\\\vec u||\\\\vec v| \", \"\\\\\", \"\\n\\\\vec u \\\\cdot \\\\vec v &\\\\leq |\\\\vec u||\\\\vec v|\\n\\\\end{aligned}\\n$$\"), mdx(\"p\", null, \"which follow from [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"cauchy-schwarz-inequality\",\n    \"title\": \"Cauchy-Schwarz Inequality\"\n  }, \"cauchy-schwarz-inequality\"), \"]\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"13c561a3-4769-554f-82a2-2d2d67209ce1","fields":{"slug":"/ma2104/triangle-inequality","title":"Triangle Inequality"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"euclidean-spaces\"\n  }, \"Euclidean Spaces\"), mdx(\"p\", null, \"Fix a natural number $n \\\\in \\\\N$.\"), mdx(\"p\", null, \"Set $\\\\R^n := \\\\R \\\\times \\\\R \\\\times ... \\\\times \\\\R :=$ { all ordered $n$-tuples }\\ncalled the standard ($n$-dimensional) vector space (over $\\\\R$)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$n$ is called the dimension of $\\\\R^n$\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"elements of $\\\\R^n$ are called vectors, points, $n$-tuples\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"elements of $\\\\R$ are called scalars\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if $\\\\vec \\\\mathbf{u} \\\\in \\\\R^n$ is a vector,\\nthen for each $i = 1, ..., n$, we call $u_i$ the $i^{th}$ component\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the vector $\\\\vec 0 := (0, ..., 0)$ is the zero vector (origin)\")), mdx(\"h2\", {\n    \"id\": \"vectors\"\n  }, \"Vectors\"), mdx(\"h3\", {\n    \"id\": \"operations-on-vectors\"\n  }, \"Operations on Vectors\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Addition \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"add vectors componentwise\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Negation\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"apply distributively\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Scalar multiplication\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"apply distributively\")))), mdx(\"h2\", {\n    \"id\": \"dot-product\"\n  }, \"Dot Product\"), mdx(\"p\", null, \"$( \\\\cdot ) : \\\\R^n \\\\times \\\\R^n \\\\rightarrow \\\\R$\"), mdx(\"p\", null, \"$$\\\\vec u \\\\cdot \\\\vec v = \\\\sum^n_{i = 1} u_i v_i$$\"), mdx(\"h3\", {\n    \"id\": \"properties-of-dot-product\"\n  }, \"Properties of Dot Product\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Symmetric\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Commutative\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Associative w.r.t. scalar multiplication\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Distributive\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec u \\\\cdot \\\\vec u = \\\\vert \\\\vec u \\\\vert ^2$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec 0 \\\\cdot \\\\vec u = 0$\")), mdx(\"hr\", null), mdx(\"p\", null, \"Standard (n-dimensional) Euclidean space\\n: $\\\\R^n$ given with its vector space operations (+, -, scalar multiplication) and its dot product\"), mdx(\"hr\", null), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Any $\\\\vec u \\\\cdot \\\\vec u$ is always $\\\\geq 0$.\")), mdx(\"h3\", {\n    \"id\": \"length\"\n  }, \"Length\"), mdx(\"p\", null, \"$$\\\\vert \\\\vec u \\\\vert := \\\\sqrt{\\\\vec u \\\\cdot \\\\vec u}$$\"), mdx(\"h4\", {\n    \"id\": \"properties-of-vector-lengths\"\n  }, \"Properties of Vector Lengths\"), mdx(\"p\", null, \"If $\\\\vec u$ and $\\\\vec v$ are any vector and $c$ is a scalar, then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vert \\\\vec u \\\\vert  = 0$ iff $\\\\vec u = \\\\vec 0$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vert c \\\\vec u \\\\vert = \\\\vert c \\\\vert \\\\vert \\\\vec u \\\\vert$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vert \\\\vec u + \\\\vec v \\\\vert  \\\\leq  \\\\vert \\\\vec u \\\\vert  +  \\\\vert \\\\vec v \\\\vert$\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"3 follows [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"triangle-inequality\",\n    \"title\": \"Triangle Inequality\"\n  }, \"triangle-inequality\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"unit-vectors\"\n  }, \"Unit Vectors\"), mdx(\"p\", null, \"Any vector with length $1$ is a unit vector\"), mdx(\"hr\", null), mdx(\"p\", null, \"Standard unit vector\\n: vector with 1 in some component and 0 in all others\"), mdx(\"hr\", null), mdx(\"h3\", {\n    \"id\": \"proposition\"\n  }, \"Proposition\"), mdx(\"p\", null, \"Any vector in $\\\\R^n$ is a linear combination of the standard unit vectors.\"), mdx(\"h3\", {\n    \"id\": \"direction-vectors\"\n  }, \"Direction Vectors\"), mdx(\"p\", null, \"If $\\\\vec v \\\\neq 0$ then $\\\\frac{\\\\vec v}{  \\\\vert \\\\vec v \\\\vert  }$ is called the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"direction\"), \" of the vector $\\\\vec v$.\"), mdx(\"h3\", {\n    \"id\": \"angle\"\n  }, \"Angle\"), mdx(\"p\", null, \"The angle between 2 nonzero vectors $\\\\vec u$ and $\\\\vec v$ is $\\\\theta = \\\\cos^{-1}(\\\\frac{\\\\vec u \\\\cdot \\\\vec v}{\\\\vert \\\\vec u \\\\vert \\\\vert \\\\vec v \\\\vert })$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This has meaning because of [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"cauchy-schwarz-inequality\",\n    \"title\": \"Cauchy-Schwarz Inequality\"\n  }, \"cauchy-schwarz-inequality\"), \"] which restricts the possible values of $\\\\cos \\\\theta$.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Vectors $\\\\vec u$ and $\\\\vec v$ are orthogonal if $\\\\vec u \\\\cdot \\\\vec v = 0$.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The scalar component of $\\\\vec u$ in the direction of $\\\\vec v$ is the scalar\\n$$\\\\vert \\\\vec u \\\\vert  \\\\cos \\\\theta = \\\\frac{\\\\vec u \\\\cdot \\\\vec v}{ \\\\vert \\\\vec v \\\\vert } = \\\\vec u \\\\cdot \\\\frac{\\\\vec v}{ \\\\vert \\\\vec v \\\\vert }$$\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$\\\\vec u$ dot product with unit direction vector of $\\\\vec v$\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The vector projection of $\\\\vec u$ onto $\\\\vec v$ is the vector\\n$$\\\\text{proj}_v \\\\vec u = (\\\\frac{\\\\vec u \\\\cdot \\\\vec v}{ \\\\vert \\\\vec v \\\\vert ^2}) \\\\vec v = (\\\\frac{\\\\vec u \\\\cdot \\\\vec v}{ \\\\vert \\\\vec v \\\\vert }) \\\\frac{\\\\vec v}{ \\\\vert \\\\vec v \\\\vert }$$\")), mdx(\"h2\", {\n    \"id\": \"cross-product\"\n  }, \"Cross Product\"), mdx(\"h3\", {\n    \"id\": \"cross-product-on-r3\"\n  }, \"Cross Product on $\\\\R^3$\"), mdx(\"p\", null, \"$( \\\\times ) : \\\\R^3 \\\\times \\\\R^3 \\\\rightarrow \\\\R^3$\"), mdx(\"p\", null, \"$$\\\\vec u \\\\times \\\\vec v = ( \\\\vert \\\\vec u \\\\vert |\\\\vec v \\\\vert  \\\\sin \\\\theta) \\\\vec n$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The magnitude of the normal vector is the area parallelogram formed by the 2 vectors\")), mdx(\"h4\", {\n    \"id\": \"cross-product-of-standard-vectors\"\n  }, \"Cross Product of Standard Vectors\"), mdx(\"p\", null, \"$$\\\\vec i \\\\times \\\\vec j = \\\\vec k$$\\n$$\\\\vec j \\\\times \\\\vec k = \\\\vec i$$\\n$$\\\\vec k \\\\times \\\\vec i = \\\\vec j$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"RHS follows a cyclic pattern (i-j-k)\")), mdx(\"h4\", {\n    \"id\": \"properties-of-the-cross-product\"\n  }, \"Properties of the Cross Product\"), mdx(\"p\", null, \"If $\\\\vec u$, $\\\\vec v$ and $\\\\vec w$ are any vectors and $r, s$ are scalars, then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$(r \\\\vec u) \\\\times (s \\\\vec v) = (rs) (\\\\vec u \\\\times \\\\vec v)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec u \\\\times (\\\\vec v + \\\\vec w) = \\\\vec u \\\\times \\\\vec v + \\\\vec u \\\\times \\\\vec w$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec v \\\\times \\\\vec u = -(\\\\vec u \\\\times \\\\vec v)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$(\\\\vec v + \\\\vec w) \\\\times \\\\vec u = \\\\vec v \\\\times \\\\vec u + \\\\vec w \\\\times \\\\vec u$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec 0 \\\\times \\\\vec u = \\\\vec 0$\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"triple-product-formula\",\n    \"title\": \"Triple Product Formula\"\n  }, \"triple-product-formula\"), \"]\")), mdx(\"hr\", null), mdx(\"h4\", {\n    \"id\": \"proposition-1\"\n  }, \"Proposition\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For any $\\\\vec u, \\\\vec v \\\\in \\\\R^3$ one has $(\\\\vec u \\\\times \\\\vec v) \\\\cdot \\\\vec u = \\\\vec 0 = (\\\\vec u \\\\times \\\\vec v) \\\\cdot \\\\vec v$\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"and if $\\\\vec u$ and $\\\\vec v$ are both $\\\\neq \\\\vec 0$, $\\\\vert \\\\vec u \\\\times \\\\vec v \\\\vert ^2 =  \\\\vert \\\\vec u \\\\vert ^2  \\\\vert \\\\vec v \\\\vert ^2 \\\\sin^2 \\\\theta$\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$(\\\\vec u \\\\times \\\\vec v)$ is always orthogonal to both $\\\\vec u$ and $\\\\vec v$.\")), mdx(\"h4\", {\n    \"id\": \"lines-and-planes\"\n  }, \"Lines and Planes\"), mdx(\"p\", null, \"A vector equation for the line $L$, through $P_0(x_0, y_0, z_0)$ parallel to $\\\\vec v$ is\\n$$\\\\vec r(t) = \\\\vec r_0 + r \\\\vec v$$\"), mdx(\"p\", null, \"Extending the components, we get the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parametric equations for a line\"), \".\"), mdx(\"p\", null, \"$$x = x_0 + tv_1, y = y_0 + tv_2, z = z_0 + tv_3$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note that the parameterization are not unique.\\nYou can choose any scalar multiple for $\\\\vec v$ or different \\\"starting point\\\".\")), mdx(\"h5\", {\n    \"id\": \"distance-from-a-point-s-to-a-line-through-p-parallel-to-v\"\n  }, \"Distance from a Point $S$ to a Line Through $P$ parallel to $v$\"), mdx(\"p\", null, \"$$d = \\\\frac{\\\\vert \\\\vec{PS} \\\\times \\\\vec v \\\\vert}{\\\\vert \\\\vec v \\\\vert}$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"02531be3-5813-56f5-a390-11209663b616","fields":{"slug":"/ma2104/euclidean-spaces","title":"Euclidean Spaces"}}}]},"fields":{"slug":"/ma2104/cauchy-schwarz-inequality","title":"Cauchy-Schwarz Inequality"}}},"pageContext":{"id":"d801f8ed-6113-58b7-a87b-c22c136dc50f"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}