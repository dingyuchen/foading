{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/ma2104/module-ma2104","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"multivariable-calculus\"\n  }, \"Multivariable Calculus\"), mdx(\"p\", null, \"#entry\"), mdx(\"h2\", {\n    \"id\": \"module-information\"\n  }, \"Module Information\"), mdx(\"p\", null, \"Lectures will be pre-recorded and uploaded every Tuesday and Friday before 12pm in multimedia.\"), mdx(\"p\", null, \"Focus of the lectures will be on the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"mathematical concepts and proofs\"), \".\"), mdx(\"p\", null, \"Tutorials will alternate between \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lecture on a topic\"), \" (part of tested materials) and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"discussion of the homework problems\"), \".\"), mdx(\"p\", null, \"Tutorials are also pre-recorded and uploaded on Luminus before Wednesday, 2pm.\"), mdx(\"h2\", {\n    \"id\": \"assessment\"\n  }, \"Assessment\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Test\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Weightage\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"5x Homework\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"40%\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Finals\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"60%\")))), mdx(\"h2\", {\n    \"id\": \"textbook\"\n  }, \"Textbook\"), mdx(\"p\", null, \"Thomas, Calculus, 14th ed., - Hass, Heil & Weir\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Chapters 11 - 16\")), mdx(\"h2\", {\n    \"id\": \"table-of-contents\"\n  }, \"Table of Contents\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"euclidean-spaces\",\n    \"title\": \"Euclidean Spaces\"\n  }, \"euclidean-spaces\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"curves\",\n    \"title\": \"Curves in $\\\\R^n$\"\n  }, \"curves\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"multivariable-functions\",\n    \"title\": \"Multivariable Functions\"\n  }, \"multivariable-functions\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"higher-order-derivatives\",\n    \"title\": \"Higher Order Derivatives\"\n  }, \"higher-order-derivatives\"), \"] \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"multivariable-integration\",\n    \"title\": \"Multivariable Integration\"\n  }, \"multivariable-integration\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"integration-by-substitution\",\n    \"title\": \"Integration by Substitution\"\n  }, \"integration-by-substitution\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"line-integrals\",\n    \"title\": \"Line Integrals\"\n  }, \"line-integrals\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"surface-integrals\",\n    \"title\": \"Surface Integrals\"\n  }, \"surface-integrals\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"curl-of-vector-field\",\n    \"title\": \"Curl of Vector Field\"\n  }, \"curl-of-vector-field\"), \"] \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"divergence-of-vector-fields\",\n    \"title\": \"Divergence of a Vector Field\"\n  }, \"divergence-of-vector-fields\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"extreme-values\",\n    \"title\": \"Extreme Values\"\n  }, \"extreme-values\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"maxwell-equations\",\n    \"title\": \"Maxwell Equations\"\n  }, \"maxwell-equations\"), \"]\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"euclidean-spaces\"\n  }, \"Euclidean Spaces\"), mdx(\"p\", null, \"Fix a natural number $n \\\\in \\\\N$.\"), mdx(\"p\", null, \"Set $\\\\R^n := \\\\R \\\\times \\\\R \\\\times ... \\\\times \\\\R :=$ { all ordered $n$-tuples }\\ncalled the standard ($n$-dimensional) vector space (over $\\\\R$)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$n$ is called the dimension of $\\\\R^n$\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"elements of $\\\\R^n$ are called vectors, points, $n$-tuples\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"elements of $\\\\R$ are called scalars\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if $\\\\vec \\\\mathbf{u} \\\\in \\\\R^n$ is a vector,\\nthen for each $i = 1, ..., n$, we call $u_i$ the $i^{th}$ component\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the vector $\\\\vec 0 := (0, ..., 0)$ is the zero vector (origin)\")), mdx(\"h2\", {\n    \"id\": \"vectors\"\n  }, \"Vectors\"), mdx(\"h3\", {\n    \"id\": \"operations-on-vectors\"\n  }, \"Operations on Vectors\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Addition \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"add vectors componentwise\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Negation\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"apply distributively\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Scalar multiplication\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"apply distributively\")))), mdx(\"h2\", {\n    \"id\": \"dot-product\"\n  }, \"Dot Product\"), mdx(\"p\", null, \"$( \\\\cdot ) : \\\\R^n \\\\times \\\\R^n \\\\rightarrow \\\\R$\"), mdx(\"p\", null, \"$$\\\\vec u \\\\cdot \\\\vec v = \\\\sum^n_{i = 1} u_i v_i$$\"), mdx(\"h3\", {\n    \"id\": \"properties-of-dot-product\"\n  }, \"Properties of Dot Product\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Symmetric\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Commutative\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Associative w.r.t. scalar multiplication\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Distributive\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec u \\\\cdot \\\\vec u = \\\\vert \\\\vec u \\\\vert ^2$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec 0 \\\\cdot \\\\vec u = 0$\")), mdx(\"hr\", null), mdx(\"p\", null, \"Standard (n-dimensional) Euclidean space\\n: $\\\\R^n$ given with its vector space operations (+, -, scalar multiplication) and its dot product\"), mdx(\"hr\", null), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Any $\\\\vec u \\\\cdot \\\\vec u$ is always $\\\\geq 0$.\")), mdx(\"h3\", {\n    \"id\": \"length\"\n  }, \"Length\"), mdx(\"p\", null, \"$$\\\\vert \\\\vec u \\\\vert := \\\\sqrt{\\\\vec u \\\\cdot \\\\vec u}$$\"), mdx(\"h4\", {\n    \"id\": \"properties-of-vector-lengths\"\n  }, \"Properties of Vector Lengths\"), mdx(\"p\", null, \"If $\\\\vec u$ and $\\\\vec v$ are any vector and $c$ is a scalar, then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vert \\\\vec u \\\\vert  = 0$ iff $\\\\vec u = \\\\vec 0$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vert c \\\\vec u \\\\vert = \\\\vert c \\\\vert \\\\vert \\\\vec u \\\\vert$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vert \\\\vec u + \\\\vec v \\\\vert  \\\\leq  \\\\vert \\\\vec u \\\\vert  +  \\\\vert \\\\vec v \\\\vert$\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"3 follows [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"triangle-inequality\",\n    \"title\": \"Triangle Inequality\"\n  }, \"triangle-inequality\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"unit-vectors\"\n  }, \"Unit Vectors\"), mdx(\"p\", null, \"Any vector with length $1$ is a unit vector\"), mdx(\"hr\", null), mdx(\"p\", null, \"Standard unit vector\\n: vector with 1 in some component and 0 in all others\"), mdx(\"hr\", null), mdx(\"h3\", {\n    \"id\": \"proposition\"\n  }, \"Proposition\"), mdx(\"p\", null, \"Any vector in $\\\\R^n$ is a linear combination of the standard unit vectors.\"), mdx(\"h3\", {\n    \"id\": \"direction-vectors\"\n  }, \"Direction Vectors\"), mdx(\"p\", null, \"If $\\\\vec v \\\\neq 0$ then $\\\\frac{\\\\vec v}{  \\\\vert \\\\vec v \\\\vert  }$ is called the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"direction\"), \" of the vector $\\\\vec v$.\"), mdx(\"h3\", {\n    \"id\": \"angle\"\n  }, \"Angle\"), mdx(\"p\", null, \"The angle between 2 nonzero vectors $\\\\vec u$ and $\\\\vec v$ is $\\\\theta = \\\\cos^{-1}(\\\\frac{\\\\vec u \\\\cdot \\\\vec v}{\\\\vert \\\\vec u \\\\vert \\\\vert \\\\vec v \\\\vert })$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This has meaning because of [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"cauchy-schwarz-inequality\",\n    \"title\": \"Cauchy-Schwarz Inequality\"\n  }, \"cauchy-schwarz-inequality\"), \"] which restricts the possible values of $\\\\cos \\\\theta$.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Vectors $\\\\vec u$ and $\\\\vec v$ are orthogonal if $\\\\vec u \\\\cdot \\\\vec v = 0$.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The scalar component of $\\\\vec u$ in the direction of $\\\\vec v$ is the scalar\\n$$\\\\vert \\\\vec u \\\\vert  \\\\cos \\\\theta = \\\\frac{\\\\vec u \\\\cdot \\\\vec v}{ \\\\vert \\\\vec v \\\\vert } = \\\\vec u \\\\cdot \\\\frac{\\\\vec v}{ \\\\vert \\\\vec v \\\\vert }$$\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$\\\\vec u$ dot product with unit direction vector of $\\\\vec v$\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The vector projection of $\\\\vec u$ onto $\\\\vec v$ is the vector\\n$$\\\\text{proj}_v \\\\vec u = (\\\\frac{\\\\vec u \\\\cdot \\\\vec v}{ \\\\vert \\\\vec v \\\\vert ^2}) \\\\vec v = (\\\\frac{\\\\vec u \\\\cdot \\\\vec v}{ \\\\vert \\\\vec v \\\\vert }) \\\\frac{\\\\vec v}{ \\\\vert \\\\vec v \\\\vert }$$\")), mdx(\"h2\", {\n    \"id\": \"cross-product\"\n  }, \"Cross Product\"), mdx(\"h3\", {\n    \"id\": \"cross-product-on-r3\"\n  }, \"Cross Product on $\\\\R^3$\"), mdx(\"p\", null, \"$( \\\\times ) : \\\\R^3 \\\\times \\\\R^3 \\\\rightarrow \\\\R^3$\"), mdx(\"p\", null, \"$$\\\\vec u \\\\times \\\\vec v = ( \\\\vert \\\\vec u \\\\vert |\\\\vec v \\\\vert  \\\\sin \\\\theta) \\\\vec n$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The magnitude of the normal vector is the area parallelogram formed by the 2 vectors\")), mdx(\"h4\", {\n    \"id\": \"cross-product-of-standard-vectors\"\n  }, \"Cross Product of Standard Vectors\"), mdx(\"p\", null, \"$$\\\\vec i \\\\times \\\\vec j = \\\\vec k$$\\n$$\\\\vec j \\\\times \\\\vec k = \\\\vec i$$\\n$$\\\\vec k \\\\times \\\\vec i = \\\\vec j$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"RHS follows a cyclic pattern (i-j-k)\")), mdx(\"h4\", {\n    \"id\": \"properties-of-the-cross-product\"\n  }, \"Properties of the Cross Product\"), mdx(\"p\", null, \"If $\\\\vec u$, $\\\\vec v$ and $\\\\vec w$ are any vectors and $r, s$ are scalars, then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$(r \\\\vec u) \\\\times (s \\\\vec v) = (rs) (\\\\vec u \\\\times \\\\vec v)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec u \\\\times (\\\\vec v + \\\\vec w) = \\\\vec u \\\\times \\\\vec v + \\\\vec u \\\\times \\\\vec w$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec v \\\\times \\\\vec u = -(\\\\vec u \\\\times \\\\vec v)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$(\\\\vec v + \\\\vec w) \\\\times \\\\vec u = \\\\vec v \\\\times \\\\vec u + \\\\vec w \\\\times \\\\vec u$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec 0 \\\\times \\\\vec u = \\\\vec 0$\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"triple-product-formula\",\n    \"title\": \"Triple Product Formula\"\n  }, \"triple-product-formula\"), \"]\")), mdx(\"hr\", null), mdx(\"h4\", {\n    \"id\": \"proposition-1\"\n  }, \"Proposition\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For any $\\\\vec u, \\\\vec v \\\\in \\\\R^3$ one has $(\\\\vec u \\\\times \\\\vec v) \\\\cdot \\\\vec u = \\\\vec 0 = (\\\\vec u \\\\times \\\\vec v) \\\\cdot \\\\vec v$\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"and if $\\\\vec u$ and $\\\\vec v$ are both $\\\\neq \\\\vec 0$, $\\\\vert \\\\vec u \\\\times \\\\vec v \\\\vert ^2 =  \\\\vert \\\\vec u \\\\vert ^2  \\\\vert \\\\vec v \\\\vert ^2 \\\\sin^2 \\\\theta$\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$(\\\\vec u \\\\times \\\\vec v)$ is always orthogonal to both $\\\\vec u$ and $\\\\vec v$.\")), mdx(\"h4\", {\n    \"id\": \"lines-and-planes\"\n  }, \"Lines and Planes\"), mdx(\"p\", null, \"A vector equation for the line $L$, through $P_0(x_0, y_0, z_0)$ parallel to $\\\\vec v$ is\\n$$\\\\vec r(t) = \\\\vec r_0 + r \\\\vec v$$\"), mdx(\"p\", null, \"Extending the components, we get the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parametric equations for a line\"), \".\"), mdx(\"p\", null, \"$$x = x_0 + tv_1, y = y_0 + tv_2, z = z_0 + tv_3$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note that the parameterization are not unique.\\nYou can choose any scalar multiple for $\\\\vec v$ or different \\\"starting point\\\".\")), mdx(\"h5\", {\n    \"id\": \"distance-from-a-point-s-to-a-line-through-p-parallel-to-v\"\n  }, \"Distance from a Point $S$ to a Line Through $P$ parallel to $v$\"), mdx(\"p\", null, \"$$d = \\\\frac{\\\\vert \\\\vec{PS} \\\\times \\\\vec v \\\\vert}{\\\\vert \\\\vec v \\\\vert}$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"02531be3-5813-56f5-a390-11209663b616","fields":{"slug":"/ma2104/euclidean-spaces","title":"Euclidean Spaces"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"curves-in-rn\"\n  }, \"Curves in $\\\\R^n$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We won't be able to define what a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"curve\"), \" is until we have developed some necessary tools about differentiation and derivatives.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"3 usual ways of giving a curve:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"parameterized curve\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"graph of a function\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"level set of function(s)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For these descriptions to give a valid curve, some technical conditions have to be imposed on the inputs\")), mdx(\"h2\", {\n    \"id\": \"a-parameterized-curve-in-rn\"\n  }, \"A Parameterized Curve in $\\\\R^n$\"), mdx(\"p\", null, \"is a function\"), mdx(\"p\", null, \"$\\\\vec r : I \\\\rightarrow \\\\R^n$ from an interval $I \\\\subseteq \\\\R^1$ to Euclidean n-space $\\\\R^n$\"), mdx(\"p\", null, \"The domain $I$ is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parameter interval\"), \".\"), mdx(\"p\", null, \"The image $\\\\vec r(I)$ of the function $\\\\vec r$ is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"curve\"), \".\"), mdx(\"p\", null, \"The variable $t$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parameter\"), \" for the curve.\"), mdx(\"p\", null, \"For any $t \\\\in I$, $\\\\vec r(t)$ is a vector in $\\\\R^n$,\\ncan be written in component form and the function $\\\\vec r : I \\\\rightarrow \\\\R^n$ is the same as giving $n$ many single variable functions.\"), mdx(\"p\", null, \"If $I$ is a closed interval $a \\\\leq t \\\\leq b$,\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$\\\\vec r(a)$ is the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"initial point\"), \" of the curve\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$\\\\vec r(b)$ is the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"terminal point\"), \" of the curve\")), mdx(\"h2\", {\n    \"id\": \"limits-and-continuity\"\n  }, \"Limits and Continuity\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"limits-and-continuity\",\n    \"title\": \"Limits and Continuity\"\n  }, \"limits-and-continuity\"), \"]\"), mdx(\"h3\", {\n    \"id\": \"proposition\"\n  }, \"Proposition\"), mdx(\"p\", null, \"Suppose $\\\\vec r : I \\\\rightarrow \\\\R^n$ is given in component form:\"), mdx(\"p\", null, \"$$\\\\vec r(t) = (r_1(t), r_2(t), ..., r_n(t))$$\"), mdx(\"p\", null, \"Let $\\\\vec L \\\\in \\\\R^n$ be given in component form as \"), mdx(\"p\", null, \"$$\\\\vec L = (L_1, L_2, ..., L_n)$$\"), mdx(\"p\", null, \"Then $\\\\lim\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{t \\\\rightarrow t_0} \\\\vec r(t) = \\\\vec L$ in $\\\\R^n$ iff $\\\\forall j \\\\in \", \"{\", \"1, ..., n\", \"}\", \"$, one has $\\\\lim\"), \"{t \\\\rightarrow t_0} r_j(t) = \\\\vec L_j$ in $\\\\R$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We can apply analysis for one-dimension component-wise to proof properties of vector functions\")), mdx(\"h4\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"In general, if $\\\\vec v = (v_1, v_2, ..., v_n) \\\\in \\\\R^n$\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"h2\", {\n    \"id\": \"derivatives\"\n  }, \"Derivatives\"), mdx(\"p\", null, \"Let $t \\\\in I$ be given. Say $\\\\vec r$ is differentiable at $t$ iff $\\\\exists \\\\vec r'(t) \\\\in \\\\R^n$ such that\"), mdx(\"p\", null, \"$$ \\\\lim_{\\\\Delta t \\\\rightarrow 0} \\\\frac{1}{\\\\Delta t}(\\\\vec r (t + \\\\Delta t) - \\\\vec r (t)) = \\\\vec r'(t)$$\"), mdx(\"p\", null, \"Then $\\\\vec r'(t)$ is the (vector-)derivative of $\\\\vec r$ at $t$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$\\\\vec r$ is differentiable at $t$ if all its component functions are differentiable at $t$.\")), mdx(\"h3\", {\n    \"id\": \"differentiation-rules\"\n  }, \"Differentiation Rules\"), mdx(\"p\", null, \"Let $\\\\vec u$ and $\\\\vec v$ be differentiable vector functions of $t$, $\\\\vec C$ a constant vector function, $c$ any scalar, and $f$ any differentiable scalar function.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \\\\vec C = \\\\vec 0$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[c \\\\vec u (t)]\", \"= c \\\\vec u'(t)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[f(t) \\\\vec u (t)]\", \"= f'(t) \\\\vec u(t) + f(t) \\\\vec u'(t)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[\\\\vec u (t) + \\\\vec v(t)]\", \"= \\\\vec u'(t) + \\\\vec v'(t)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[\\\\vec u (t) \\\\cdot \\\\vec v(t)]\", \"= \\\\vec u'(t) \\\\cdot \\\\vec v (t) + \\\\vec u(t) \\\\cdot \\\\vec v'(t)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[\\\\vec u (f(t))]\", \"= f'(t) \\\\vec u'(f(t))$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[\\\\vec u (t) \\\\times \\\\vec v(t)]\", \"= \\\\vec u'(t) \\\\times \\\\vec v (t) + \\\\vec u(t) \\\\times \\\\vec v'(t)$\")), mdx(\"h2\", {\n    \"id\": \"integrals\"\n  }, \"Integrals\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"p\", null, \"Rieman definition of integrals transposed to $\\\\R^n$.\"), mdx(\"h2\", {\n    \"id\": \"more-definitions\"\n  }, \"More definitions\"), mdx(\"p\", null, \"$\\\\vec r$ is continuously differentiable (\\\"of class $C^1$\\\") iff $\\\\vec r$ is differentiable and $\\\\vec r' : I \\\\rightarrow \\\\R^n$ is continuous.\"), mdx(\"hr\", null), mdx(\"p\", null, \"The parameterized curve given by $\\\\vec r$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"smooth\"), \" iff $\\\\vec r$ is continuously differentiable and has [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"non-vanishing-derivative\",\n    \"title\": \"Non-Vanishing Derivative\"\n  }, \"non-vanishing-derivative\"), \"]s.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\\"smooth\\\" has a different technical definition in analysis, geometry, etc.\")), mdx(\"hr\", null), mdx(\"p\", null, \"The parameterized curve given by $\\\\vec r : I \\\\rightarrow \\\\R^n$ is piecewise smooth iff $\\\\vec r$ is continuous,\"), mdx(\"p\", null, \"and exists a partition of the interval $I = \", \"[a, b]\", \"$, say \"), mdx(\"p\", null, \"$$a = t\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 < t_1 < ... < t\"), \"{n - 1} < t_n = b$$\"), mdx(\"p\", null, \"such that $\\\\forall j \\\\in {1, ..., n}$, $\\\\vec r$ restricted to $\", \"[t_{j - 1}, t_j]\", \"$ is smooth.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Thus $\\\\vec r$ is allowed to be non-differentiable at the partition points $\\\\vec r(t_1), \\\\vec r(t_2), ..., \\\\vec r(t_n)$ \")), mdx(\"h2\", {\n    \"id\": \"arc-length\"\n  }, \"Arc Length\"), mdx(\"p\", null, \"Let $I = \", \"[a, b]\", \" \\\\subseteq \\\\R'$ be a closed interval.\"), mdx(\"p\", null, \"Let $\\\\vec r : I \\\\rightarrow \\\\R^n$ be a smooth parameterized curve in $\\\\R^n$.\"), mdx(\"p\", null, \"The length of the curve parameterized by $\\\\vec r$ is defined to be the integral \"), mdx(\"p\", null, \"$$\\\\int^b_a \\\\vert \\\\vec r '(t) \\\\vert \\\\, dt$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If $\\\\vec r$ is piecewise smooth, its length is defined to be the sum of the length of its smooth pieces.\")), mdx(\"h3\", {\n    \"id\": \"remark\"\n  }, \"Remark\"), mdx(\"p\", null, \"Why is this definition of length reasonable?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Take a line segment in $\\\\R^n$. Note that integration length agrees with the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Euclidean space length\"), \" of the vector represented by that line segment.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"9798d058-8405-5f74-90ae-b9aa563d16c9","fields":{"slug":"/ma2104/curves","title":"Curves in $\\R^n$"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"multivariable-functions\"\n  }, \"Multivariable Functions\"), mdx(\"p\", null, \"Multivariable Functions\"), mdx(\"p\", null, \"An \\\"$n$-dimensional\\\" vector-valued function of \\\"$m$-variables\\\" is a function of the form $f: R \\\\rightarrow \\\\R^n$ where\\n$R \\\\subseteq \\\\R^m$ is a (open) region.\"), mdx(\"p\", null, \"Take the function to take in a $m$-dimensional vector as input and returns a $n$-dimensional vector.\"), mdx(\"h2\", {\n    \"id\": \"limits\"\n  }, \"Limits\"), mdx(\"p\", null, \"$\\\\epsilon - \\\\delta$ defintion for multivariable functions.\"), mdx(\"p\", null, \"Let $t_o \\\\in I$ and $\\\\vec L \\\\in \\\\R^n$. Say $\\\\vec r$ has limit $\\\\vec L$ as $t \\\\rightarrow t_0$ iff \"), mdx(\"p\", null, \"$$\\\\forall \\\\epsilon \\\\in \\\\R\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{>0}, \\\\exist \\\\delta \\\\in \\\\R\"), \"{>0}$$\"), mdx(\"h3\", {\n    \"id\": \"limit-laws\"\n  }, \"Limit Laws\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"continuity\"\n  }, \"Continuity\"), mdx(\"p\", null, \"A function $f$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"continuous at the point $\\\\bold x_0$\"), \" if \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f$ is defined at $\\\\bold x_0$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\lim_{\\\\bold x \\\\rightarrow \\\\bold x_0} f(\\\\bold x)$ exists\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\lim_{\\\\bold x \\\\rightarrow \\\\bold x_0} f(\\\\bold x) = f(\\\\bold x_0)$.\")), mdx(\"p\", null, \"A function is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"continuous\"), \" if it is continuous at every point in its domain.\"), mdx(\"h3\", {\n    \"id\": \"continuity-of-compositions\"\n  }, \"Continuity of Compositions\"), mdx(\"p\", null, \"Suppose $f: S \\\\rightarrow \\\\R^m, S \\\\subseteq \\\\R^l$\\nand $g: R \\\\rightarrow \\\\R^n, S \\\\subseteq \\\\R^m$\\nand $f(S) \\\\subseteq R$ (so that $g \\\\circ f : S \\\\rightarrow \\\\R^n$ is defined)\"), mdx(\"p\", null, \"For any $\\\\vec q_0 \\\\in S$, if $f$ is continuous at $\\\\vec q_0$\\nand $g$ is continuous at $f(\\\\vec q_0)$\\nthen $g \\\\circ f$ is continuous at $\\\\vec q_0$.\"), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"h2\", {\n    \"id\": \"differentiability\"\n  }, \"Differentiability\"), mdx(\"p\", null, \"There must exist some linear transformation $A$ such that \"), mdx(\"p\", null, \"Say $f$ is differentiable at $\\\\vec p\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 \\\\in R$ iff\\nthere exists a linear transformation $A : \\\\R^m \\\\rightarrow \\\\R^n$\\nsuch that $\\\\forall \\\\epsilon \\\\in \\\\R\"), \"{> 0}, \\\\exist \\\\delta \\\\in \\\\R_{>0}$ such that\"), mdx(\"p\", null, \"$$\\\\vert f(\\\\vec p) - (f(\\\\vec p_0) + A \\\\cdot (\\\\vec p - \\\\vec p_0)) \\\\vert \\\\leq \\\\epsilon \\\\vert \\\\vec p - \\\\vec p_0 \\\\vert$$\"), mdx(\"p\", null, \"The linear transformation $A$ is the uniquely determined (if it exists) and is called the (total) derivative of $f$ at $p_0$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"uses hypothesis that $R$ is open.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Say $f$ is continuously differentiable on $R$ iff $f$ is differentiable on $R$ and $f'$ is differentiable.\")), mdx(\"h2\", {\n    \"id\": \"differentiability-implies-continuity\"\n  }, \"Differentiability Implies Continuity\"), mdx(\"p\", null, \"Suppose $f: R \\\\rightarrow \\\\R^n$ is differentiable at $\\\\vec p_0 \\\\in R$, then\\n$f$ is continuous.\"), mdx(\"h2\", {\n    \"id\": \"directional-derivative\"\n  }, \"Directional Derivative\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"derivative of $f$ at point $p_0$ in the direction of the vector $\\\\vec u$\"), \".\"), mdx(\"p\", null, \"Let $R \\\\subseteq \\\\R^m$ be an open region.\"), mdx(\"p\", null, \"Let $f : R \\\\rightarrow \\\\R^n$ be a function.\"), mdx(\"p\", null, \"Let $\\\\vec u \\\\in \\\\R^m$ be any vector(\\\"direction\\\").\"), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"derivative of $f$ in the direction $\\\\vec u$ at $\\\\vec p_0 \\\\in R$\"), \" is the limit\\n$(D_{\\\\vec u} f)(\\\\vec p_0) \\\\in \\\\R^n$ given by\"), mdx(\"p\", null, \"$$(D\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{\\\\vec u} f)(\\\\vec p_0) := \\\\lim\"), \"{s \\\\rightarrow 0} \\\\frac{f( \\\\vec p_0 + s \\\\vec u ) - f(\\\\vec p_0)}{s}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Consider a (small) open interval $I = (-c, c) \\\\subseteq \\\\R$ such that $\\\\forall s \\\\in I$, one has $\\\\vec p_0 + s \\\\cdot \\\\vec u \\\\in R$.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"to get function $f\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{\\\\vec u, \\\\vec p_0} : I \\\\rightarrow \\\\R^n, f\"), \"{\\\\vec u, \\\\vec p_0} := f(\\\\vec p_0 + s \\\\cdot \\\\vec u)$\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Then $(D\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{\\\\vec u} f)(\\\\vec p_0) = (\\\\frac{d}{ds} f\"), \"{\\\\vec u, \\\\vec p_0})(0)$.\")), mdx(\"h2\", {\n    \"id\": \"partial-derivatives\"\n  }, \"Partial Derivatives\"), mdx(\"p\", null, \"The partial derivatives are the directional derivatives of $f$ at $p_0$ in the basis vector directions.\"), mdx(\"p\", null, \"In general:\"), mdx(\"p\", null, \"Let $R \\\\subseteq \\\\R^m$ be an open region.\"), mdx(\"p\", null, \"Let $f : R \\\\rightarrow \\\\R^n$ be a function.\"), mdx(\"p\", null, \"Let $\\\\vec e_1, ... \\\\vec e_m \\\\in \\\\R^m$ be the standard basis vectors.\"), mdx(\"p\", null, \"For $j \\\\in \", \"{\", \" 1, ..., m \", \"}\", \"$, the $j^{th}$ partial derivative of $f$ at $p\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 \\\\in R$ is the derivative of $f$ in the direction $\\\\vec e_j$ at $\\\\vec p_0 \\\\in R$\\ndenoted as $\\\\frac{\\\\partial f}{\\\\partial x_j}(\\\\vec p_0)$ or $f\"), \"{x_j}(\\\\vec p_0)$.\"), mdx(\"p\", null, \"Thus \"), mdx(\"p\", null, \"$$ \\\\frac{\\\\partial f}{\\\\partial x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"j}(\\\\vec p_0) = f\"), \"{x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"j}(\\\\vec p_0) = (D\"), \"{\\\\vec e_j}f)(\\\\vec p_0) $$\"), mdx(\"p\", null, \"is the limit\"), mdx(\"p\", null, \"$$\\\\lim_{s \\\\rightarrow 0} \\\\frac{f( \\\\vec p_0 + s \\\\vec e_j ) - f(\\\\vec p_0)}{s}$$\"), mdx(\"p\", null, \"in $\\\\R^n$ (if it exists).\"), mdx(\"h2\", {\n    \"id\": \"relationship-between-derivatives\"\n  }, \"Relationship between Derivatives\"), mdx(\"p\", null, \"Suppose $f: R \\\\rightarrow \\\\R^n$ is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"differentiable at $\\\\vec p_0 \\\\in R$\"), \" (so the total derivative exists and is a linear transformation $\\\\R^m \\\\rightarrow \\\\R^n$)\"), mdx(\"p\", null, \"Then for any $\\\\vec u \\\\in \\\\R^n$, the $\\\\vec u$-directional derivative $(D_{\\\\vec u} f)(\\\\vec p_0)$ of $f$ at $\\\\vec p_0$ exists and is equal to \"), mdx(\"p\", null, \"$$(D_{\\\\vec u} f)(\\\\vec p_0) = (Df)(\\\\vec p_0) \\\\times \\\\vec u \\\\in \\\\R^n$$\"), mdx(\"p\", null, \"In particular, for each $j \\\\in \", \"{\", \"1, ..., m\", \"}\", \"$,\\nthe $j^{th}$ partial derivative $\\\\frac{\\\\partial f}{\\\\partial x_j} (\\\\vec p_0)$ of $f$ at $\\\\vec p_0$ exists and is equal to \"), mdx(\"p\", null, \"$$\\\\frac{\\\\partial f}{\\\\partial x_j}(\\\\vec p_0) = (Df)(\\\\vec p_0) \\\\times \\\\vec e_j \\\\in \\\\R^n$$\"), mdx(\"p\", null, \"which is the $j^{th}$ column of the total derivative.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"It can happen that all partial derivatives exist but the function is not continuous at $\\\\vec p_0$, hence not differentiable.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"80ffffd2-a40b-5007-b8b3-9d5214451d93","fields":{"slug":"/ma2104/multivariable-functions","title":"Multivariable Functions"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"higher-order-derivatives\"\n  }, \"Higher Order Derivatives\"), mdx(\"h2\", {\n    \"id\": \"twice-continuously-differentiable\"\n  }, \"Twice Continuously Differentiable\"), mdx(\"p\", null, \"Say $f$ is twice continuously differentiable iff $f$ is differentiable on $R$\\nand $f'$ is differentiable as a function $R \\\\rightarrow \\\\mathbb{M}_{n \\\\times m}$.\"), mdx(\"p\", null, \"In general, say $f$ is of class $C^0$ iff $f$ is continuous.\"), mdx(\"p\", null, \"For $r \\\\geq 1$, say $f$ is of class $C^r$ iff $f$ is differentiable on $R$ and $f'$ is of class $C^{r - 1}$.\"), mdx(\"h2\", {\n    \"id\": \"characterization-of-continuous-differentiability\"\n  }, \"Characterization of Continuous Differentiability\"), mdx(\"p\", null, \"A function $f: R \\\\rightarrow \\\\R^n$, is of class $C^r$ iff\\nfor each $i \\\\in \", \"{\", \"1, ..., n\", \"}\", \"$ , for each $j \\\\in \", \"{\", \"1, ..., m\", \"}\", \"$,\\nfor all $\\\\vec p_0 \\\\in R$,\\nthe $j^{th}$ partial derivative $\\\\frac{\\\\partial f_i}{\\\\partial x_j}(\\\\vec p_0)$ of $f_i$ at $\\\\vec p_0$ exists,\\nand the function $\\\\frac{\\\\partial f_i}{\\\\partial x_j} : R \\\\rightarrow \\\\R$ is of class $C^{r-1}$.\"), mdx(\"hr\", null), mdx(\"h3\", {\n    \"id\": \"notation\"\n  }, \"Notation\"), mdx(\"p\", null, \"$$ \\\\frac{\\\\partial^r f\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i}{\\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"d} \\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{d-1}}...\\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}} := \\\\frac{\\\\partial}{\\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"d}} \\\\bigg (\\\\frac{\\\\partial^{r-1}f_i}{\\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{d - 1}}... \\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}} \\\\bigg ) := ({f_i})\"), \"{x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{j_1}...x\"), \"{j_d}}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note the reverse in pattern\")), mdx(\"hr\", null), mdx(\"p\", null, \"$f : R \\\\rightarrow \\\\R^n$ is of class $C^r$ iff\\nfor each $i \\\\in \", \"{\", \"1, ..., n\", \"}\", \"$ , for each $j \\\\in \", \"{\", \"1, ..., m\", \"}\", \"$,\"), mdx(\"p\", null, \"the function $(f\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i)\"), \"{x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{j_1}...x\"), \"{j_r}} : R \\\\rightarrow \\\\R$ exists and is continuous.\"), mdx(\"h2\", {\n    \"id\": \"equality-of-mixed-partial-derivatives\"\n  }, \"Equality of Mixed Partial Derivatives\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The indices can be in any order, the partial derivative will be the same.\")), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"Requires [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../ma3110/mean-value-theorem\",\n    \"title\": \"Mean Value Theorem\"\n  }, \"mean-value-theorem\"), \"], which is not in the scope of this module.\"), mdx(\"h2\", {\n    \"id\": \"taylors-theorem-for-multivariables\"\n  }, \"Taylor's Theorem for Multivariables\"), mdx(\"hr\", null), mdx(\"p\", null, \"Recall [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../ma3110/taylors-theorem\",\n    \"title\": \"Taylor's Theorem\"\n  }, \"taylors-theorem\"), \"]\"), mdx(\"h3\", {\n    \"id\": \"remainder-estimation-theorem\"\n  }, \"Remainder Estimation Theorem\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"remainder-estimation-theorem\",\n    \"title\": \"Remainder Estimation Theorem\"\n  }, \"remainder-estimation-theorem\"), \"]\"), mdx(\"hr\", null), mdx(\"p\", null, \"Let $f: R \\\\rightarrow \\\\R$ be a (scalar-valued) function on $R$ open in $\\\\R^m$ of class $C^{r + 1}$ ($r \\\\geq 1$).\"), mdx(\"p\", null, \"Let $\\\\vec p\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 \\\\in R$, and suppose $\\\\delta \\\\in \\\\R\"), \"{> 0}$, such that $B_{\\\\R^m}(\\\\vec p_0, \\\\delta) \\\\subseteq R$\"), mdx(\"p\", null, \"Then $\\\\forall \\\\vec \\\\xi \\\\in \\\\R^m$ with $\\\\vert \\\\vec \\\\xi \\\\vert < \\\\delta$, one has\"), mdx(\"p\", null, \"$$ f(\\\\vec p\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 + \\\\vec \\\\xi) = \\\\sum^e\"), \"{d = 0} \\\\sum_{\\\\alpha \\\\in \\\\N^m, \\\\vert \\\\alpha \\\\vert = d} \\\\frac{1}{\\\\alpha !} \\\\frac{\\\\partial^d f}{\\\\partial x_1^{\\\\alpha_1} ...\\\\partial x_m^{\\\\alpha_m}} (\\\\vec p_0) \\\\cdot \\\\xi_1^{\\\\alpha_1} ... \\\\xi_m^{\\\\alpha_m} + R(\\\\vec \\\\xi)$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"sum over degrees $d$ up to $r$\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"sum over all $m$-tuples of exponents of degree $d$\")), mdx(\"p\", null, \"where $\\\\alpha = (\\\\alpha\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1, ..., \\\\alpha_m) \\\\in \\\\Z^m\"), \"{\\\\geq 0}$\"), mdx(\"p\", null, \"$\\\\vert \\\\alpha \\\\vert = \\\\alpha_1 + ... + \\\\alpha_m$\"), mdx(\"p\", null, \"$\\\\alpha ! = \\\\alpha_1 ! + ... + \\\\alpha_m !$\"), mdx(\"p\", null, \"and $\\\\exist c \\\\in (0, 1)$ such that\"), mdx(\"p\", null, \"$$\\nR(\\\\vec \\\\xi) = \\\\sum_{\\\\alpha \\\\in \\\\N^m, \\\\vert \\\\alpha \\\\vert = d} \\\\frac{1}{\\\\alpha !} \\\\frac{\\\\partial^{r + 1} f}{\\\\partial x_1^{\\\\alpha_1} ...\\\\partial x_m^{\\\\alpha_m}} (\\\\vec p_0 + c \\\\vec \\\\xi) \\\\cdot \\\\xi_1^{\\\\alpha_1} ... \\\\xi_m^{\\\\alpha_m}\\n$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"d27521e7-827c-52ad-bbee-9517eb53e40c","fields":{"slug":"/ma2104/higher-order-derivatives","title":"Higher Order Derivatives"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"multivariable-integration\"\n  }, \"Multivariable Integration\"), mdx(\"h2\", {\n    \"id\": \"integral-of-a-function\"\n  }, \"Integral of a Function\"), mdx(\"p\", null, \"For any compact rectangle $X$ in Euclidean space, we will \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"specify a vector space $R(X)$ of $\\\\R$-valued functions on $X$.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"define a linear map $R(X) \\\\rightarrow \\\\R$, $f \\\\rightarrow \\\\int_X f(x) \\\\; dx$.\")), mdx(\"p\", null, \"A compact rectangle in $\\\\R^m$ is a subset $X \\\\subseteq \\\\R^m$ of the form $X = X_1 \\\\times X_2 \\\\times ... X_m$\\nwhere each $X_i$ is a closed and bounded interval in $\\\\R$.\"), mdx(\"p\", null, \"The volume of $X$ is $\\\\vert X \\\\vert := \\\\prod^m\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{i = 1} (b_i - a_i) \\\\in \\\\R\"), \"{\\\\geq 0}$\"), mdx(\"p\", null, \"A partition of $X\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i$ is a collection of closed sub-intervals of $X_i$ of the form $P_i = \", \"{\", \"[x_0, x_1]\", \", ..., [x\"), \"{k - 1}, x_k] \", \"}\", \"$\"), mdx(\"p\", null, \"A partition of $X$ is a collection of subsets of $X$ of the form $P_i = \", \"{\", \"R_1 \\\\times ... \\\\times R_m \\\\subseteq X : R_1 \\\\in P_1, ..\", \"}\", \"$\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"norm\"), \" of $P$ is $\\\\Vert P \\\\Vert = \\\\max\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i (\\\\max\"), \"{R_i \\\\in P_i} \\\\vert R_i \\\\vert)$\\ni.e. the maximum side length among the pieces in $P$.\"), mdx(\"h2\", {\n    \"id\": \"riemann-sum\"\n  }, \"Riemann Sum\"), mdx(\"p\", null, \"Let $X \\\\subseteq \\\\R^m$ be a compact rectangle,\\nlet $f: X \\\\rightarrow \\\\R^n$ be a vector valued function on $X$.\"), mdx(\"p\", null, \"For any partition $P$ of $X$,\\nfor any function $t: P \\\\rightarrow X$ such that $\\\\forall R \\\\in P$, $t(R) \\\\in R$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"choose a point in that partition\")), mdx(\"p\", null, \"the Riemann Sum of $f$  with respect to $P$ and $t$ is\"), mdx(\"p\", null, \"$$S(f; P, t) := \\\\sum_{R \\\\in P} f(t(R)) \\\\cdot \\\\vert R \\\\vert \\\\; \\\\in \\\\R^n$$\"), mdx(\"h2\", {\n    \"id\": \"riemann-integrable\"\n  }, \"Riemann Integrable\"), mdx(\"p\", null, \"We say that the function $f: X \\\\rightarrow \\\\R^n$ is Riemann integrable iff\\nthe limit $\\\\lim_{P, t, \\\\Vert P \\\\Vert \\\\rightarrow 0} S(f; P, t)$ exists in $\\\\R^n$.\"), mdx(\"p\", null, \"$\\\\exist L \\\\in \\\\R^n$ such that $\\\\forall \\\\epsilon \\\\in \\\\R_{\\\\geq 0}$, $\\\\exist \\\\delta > 0$ such that \"), mdx(\"p\", null, \"$\\\\forall$ partition $P$ of $X$ with $\\\\Vert P \\\\Vert < \\\\delta$\"), mdx(\"p\", null, \"$\\\\forall$ function $t: P \\\\rightarrow X$ with $\\\\forall R \\\\in P$, $t(R) \\\\in R$,\"), mdx(\"p\", null, \"one has $\\\\vert S(f; P, t)- L \\\\vert < \\\\epsilon$\"), mdx(\"p\", null, \"When this holds, the vector $L \\\\in \\\\R^n$ is uniquely determined by $f$ and is denoted $\\\\int_X f(x) \\\\; dx$ called the Riemann integral of $f$ over $X$.\"), mdx(\"h2\", {\n    \"id\": \"properties-of-riemann-integrals\"\n  }, \"Properties of Riemann Integrals\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Constant multiple\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Linear over sum and difference\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Domination ($\\\\int$ is order-preserving)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Additivity: Sum of non overlapping regions\")), mdx(\"h2\", {\n    \"id\": \"theorem\"\n  }, \"Theorem\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"non trivial!\")), mdx(\"p\", null, \"Every continuous function on $X$ (compact rectangle) is Riemann integrable.\"), mdx(\"p\", null, \"More generally,\"), mdx(\"p\", null, \"A function $f:X \\\\rightarrow \\\\R$ is Riemann integrable iff $f$ is bounded and $Dis(f) := \", \"{\", \" x \\\\in X : \\\\text{f is not continuous on X}\", \"}\", \"$\\nis of measure $0$ in $\\\\R^m$.\"), mdx(\"p\", null, \"This means $\\\\forall \\\\epsilon \\\\in \\\\R_{> 0}$, $\\\\exist$ rectangles $R_1, R_2, ..., R_n \\\\in \\\\R^m$ such that $Dis(f) \\\\subseteq R_1 \\\\cup, ..., \\\\cup R_n$ and $\\\\vert R_1 \\\\vert + ... < \\\\epsilon$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The discontinuous points are small enough that they don't affect volume.\")), mdx(\"h2\", {\n    \"id\": \"fubini-theorem-for-riemann-integral\"\n  }, \"Fubini Theorem for Riemann Integral\"), mdx(\"p\", null, \"Let $X \\\\subseteq \\\\R^m$ and $Y \\\\in \\\\R^l$ be compact rectangles\"), mdx(\"p\", null, \"Let $f: X \\\\times Y \\\\rightarrow \\\\R$ be a Riemann integrable function.\"), mdx(\"p\", null, \"If the function $F: X \\\\rightarrow \\\\R$, $F(x) = \\\\int_Y f(x, y) \\\\; dy$ is defined.\"), mdx(\"p\", null, \"then $F$ is Riemann integrable over $X$, and \"), mdx(\"p\", null, \"$$\\\\int_{X \\\\times Y} f(x,y) \\\\; d(x, y) = \\\\int_X F(x) \\\\; dy = \\\\int_X \\\\int_Y f(x, y) \\\\; dy \\\\; dx$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This allows us to reduce integration in $m$ variables to iterated integration in 1 variable\")), mdx(\"h3\", {\n    \"id\": \"consequence\"\n  }, \"Consequence\"), mdx(\"p\", null, \"If $f: X \\\\times Y \\\\rightarrow \\\\R$ is continuous on $X \\\\times Y$.\\nThen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Y \\\\int_X f(x, y) \\\\; dx \\\\; dy = \\\\int\"), \"{X \\\\times Y} f(x,y) \\\\; d(x, y) = \\\\int_X \\\\int_Y f(x, y) \\\\; dy \\\\; dx$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2caba198-92f2-5639-bafe-4a37c1a4097e","fields":{"slug":"/ma2104/multivariable-integration","title":"Multivariable Integration"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"integration-by-substitution\"\n  }, \"Integration by Substitution\"), mdx(\"p\", null, \"Suppose that the functions $\\\\phi : \", \"[a, b]\", \" \\\\rightarrow \\\\R$ is such that $\\\\phi'$ exists and is integrable on $\", \"[a, b]\", \"$.\"), mdx(\"p\", null, \"If $f:I \\\\rightarrow \\\\R$ is continuous on an interval $I$ containing $\\\\phi(\", \"[a, b]\", \")$, then\"), mdx(\"p\", null, \"$$\\\\int^b\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"a f(\\\\phi(t))\\\\phi'(t) dt = \\\\int^{\\\\phi(b)}\"), \"{\\\\phi(a)} f(x) dx$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"6d653cfc-edb2-5219-865f-5b78ba45a8b3","fields":{"slug":"/ma3110/integration-by-substitution","title":"Integration by Substitution"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"line-integrals\"\n  }, \"Line Integrals\"), mdx(\"h2\", {\n    \"id\": \"line-integral-of-scalar-valued-functions\"\n  }, \"Line Integral of (scalar-valued) functions\"), mdx(\"p\", null, \"A parametrized curve in $\\\\R^n$ is a function\\n$\\\\vec r : I \\\\rightarrow \\\\R^n$ from an interval $I \\\\subseteq \\\\R$ to Euclidean n-space $\\\\R^n$.\"), mdx(\"p\", null, \"The parametrized curve given by $\\\\vec r$ is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"smooth\"), \" iff\\n$\\\\vec r$ is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"continuously differentiable\"), \" and has \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"non-vanishing derivative\"), \". $(\\\\vec r (t) \\\\neq 0) \\\\forall t in I$.\"), mdx(\"p\", null, \"Geometrically, we think of the image set $C := \\\\vec r (I) \\\\subseteq \\\\R^n$ as a smooth \\\"curve\\\" in $\\\\R^n$ and the function $\\\\vec r : I \\\\rightarrow C$ as a (auxiliary) parametrization.\"), mdx(\"h3\", {\n    \"id\": \"smooth-curve\"\n  }, \"Smooth curve\"), mdx(\"p\", null, \"A smooth curve in $\\\\R^n$ is a subset $C \\\\subseteq \\\\R^n$ such that there exists a bijective smooth parametrization $\\\\vec r : I \\\\rightarrow C$, where $I \\\\subseteq \\\\R$ is an interval\"), mdx(\"hr\", null), mdx(\"p\", null, \"Suppose $\\\\vec r : I \\\\rightarrow C, \\\\vec s : J \\\\rightarrow C$ are bijective smooth parametrizations.\"), mdx(\"p\", null, \"Then there exists a bijective \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"continuously differentiable\"), \" map $\\\\Phi : I \\\\rightarrow J$ such that $\\\\vec r = \\\\vec s \\\\circ \\\\Phi$.\"), mdx(\"hr\", null), mdx(\"p\", null, \"Let $C$ be a smooth curve in $\\\\R^n$.\\nLet $f : C \\\\rightarrow \\\\R$ be a scalar valued function on $C$.\"), mdx(\"p\", null, \"The line integral of $f$ over $C$ is $\\\\int_C f \\\\; ds \\\\in \\\\R$ defined as follows\"), mdx(\"p\", null, \"Choose any bijective smooth parametrization $\\\\vec r : I \\\\rightarrow C$.\\nSet\"), mdx(\"p\", null, \"$$\\\\int_C f \\\\; ds := \\\\int_I f(\\\\vec r(t)) \\\\vert \\\\vec r'(t) \\\\vert \\\\; dt$$\"), mdx(\"p\", null, \"This is well-defined, independent of choice of parameter $\\\\vec r$\"), mdx(\"h4\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"If $\\\\vec s : J \\\\rightarrow C$ is another, then by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fact^\"), \", there exists $\\\\Phi : I \\\\rightarrow J$ such that $\\\\vec r = \\\\vec s \\\\circ \\\\Phi$\"), mdx(\"p\", null, \"Thus by change of variable $u = \\\\Phi(t)$.\"), mdx(\"p\", null, \"$$ \\\\int_I f(\\\\vec r (t)) \\\\vert \\\\vec r'(t) \\\\vert \\\\; dt\\n= \\\\int_I f(\\\\vec s (\\\\Phi(t))) \\\\cdot \\\\vert \\\\vec s'(\\\\Phi(t)) \\\\vert \\\\vert \\\\Phi'(t) \\\\vert \\\\; dt\\n= \\\\int_J f(\\\\vec s(u)) \\\\cdot \\\\vert \\\\vec s'(u) \\\\vert \\\\; du $$\"), mdx(\"h2\", {\n    \"id\": \"additivity\"\n  }, \"Additivity\"), mdx(\"p\", null, \"Line integrals have the useful property that if a piecewise smooth curve $C$ is made by joining a finite number of smooth curves $C_1, C_2, .., C_n$ end to end,\\nthen the integral of a function over $C$ is the sum of the integrals over the curves that make it up.\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"C f \\\\; ds = \\\\int\"), \"{C\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1} f \\\\; ds + \\\\int\"), \"{C\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2} f \\\\; ds + ... + \\\\int\"), \"{C_n} f \\\\; ds $$\"), mdx(\"h1\", {\n    \"id\": \"vector-fields\"\n  }, \"Vector Fields\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"gradient of a function\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"line integral of a vector field\")), mdx(\"p\", null, \"Let $X$ be any subset of $\\\\R^n$.\\nA \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"vector field\"), \" on $X$ is a vector-valued function $\\\\vec F : X \\\\rightarrow \\\\R^n$ from $X$ to $\\\\R^n$.\\nThe vector field $\\\\vec F : X \\\\rightarrow \\\\R^n$ is continuous / smooth iff $\\\\vec F$ (as a vector-valued function) is continuous / smooth\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Same as vector-valued function, just that output dimension is the same as input\")), mdx(\"h2\", {\n    \"id\": \"types\"\n  }, \"Types\"), mdx(\"h3\", {\n    \"id\": \"constant-vector-field\"\n  }, \"Constant Vector Field\"), mdx(\"p\", null, \"Fix any vector $\\\\vec v_0 \\\\in \\\\R^n$\"), mdx(\"p\", null, \"Set $\\\\vec F : X \\\\rightarrow \\\\R^n$ to be $\\\\vec F (\\\\vec p) := \\\\vec v_0$\"), mdx(\"h3\", {\n    \"id\": \"position-vector-field\"\n  }, \"\\\"Position\\\" Vector Field\"), mdx(\"p\", null, \"$\\\\vec F : X \\\\rightarrow \\\\R^n$ to be $\\\\vec F (\\\\vec p) := \\\\vec p$.\"), mdx(\"h2\", {\n    \"id\": \"gradient-field\"\n  }, \"Gradient Field\"), mdx(\"p\", null, \"Let $U \\\\subseteq \\\\R^n$ be an open set,\\nand $f: U \\\\rightarrow \\\\R$ be a scalar-valued differentiable function\"), mdx(\"p\", null, \"The gradient $\\\\nabla f$ of $f$ is the total derivative map of $f' : U \\\\rightarrow \\\\mathbb{M}_{1 \\\\times n}(\\\\R) = \\\\R^n$ (regarded as a vector field on $U$)\"), mdx(\"p\", null, \"Explicitly, $\\\\nabla f: U \\\\rightarrow \\\\R^n$ is given by\\nfor each $\\\\vec p \\\\in U$, partial differentiation on each component.\"), mdx(\"p\", null, \"Thus $\\\\nabla f$ is a vector field on $U$, \"), mdx(\"p\", null, \"is continuous vector field iff $f$ is continuously differentiable.\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"gradient vector field\"), \" on $U$ is a vector field $\\\\vec F : U \\\\rightarrow \\\\R^n$\\nsuch that there exists a scalar-valued differentiable function $f: U \\\\rightarrow \\\\R$ such that $\\\\vec F = \\\\nabla f$.\"), mdx(\"p\", null, \"When this is so, the function $f$ is called a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"potential function\"), \" of (the vector field) $\\\\vec F$.\"), mdx(\"h3\", {\n    \"id\": \"algebra-rules-for-gradients\"\n  }, \"Algebra Rules for Gradients\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sum Rule\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Difference Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Constant Multiple Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Product Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Quotient Rule\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Similar to single variate differentiation\")), mdx(\"h2\", {\n    \"id\": \"line-integral-of-vector-field-over-a-curve\"\n  }, \"Line Integral of Vector Field over a Curve\"), mdx(\"p\", null, \"Let $C$ be a smooth curve in $\\\\R^n$ given with a bijective smooth parameterization $\\\\vec r : I \\\\rightarrow C$\"), mdx(\"p\", null, \"Let $\\\\vec F : C \\\\rightarrow \\\\R$ be a continuous vector field on $C$.\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"line integral\"), \" of $\\\\vec F$ over $C$ with respect to $\\\\vec r$ is defined as\"), mdx(\"p\", null, \"$$\\\\int_C \\\\vec F \\\\cdot d \\\\vec r := \\\\int_I \\\\vec F(\\\\vec r (t)) \\\\cdot \\\\vec r '(t) \\\\; dt$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This depends on the chosen parameter $\\\\vec r$ of $C$ but only up to orientation:\")), mdx(\"p\", null, \"If $\\\\vec s : J \\\\rightarrow C$ is another parameterization\\nthen there exists $\\\\Phi : I \\\\rightarrow J$ that is a contin differentiable bijection\\nsuch that $\\\\vec r = \\\\vec s \\\\circ \\\\Phi$.\"), mdx(\"p\", null, \"If $\\\\Phi' : I \\\\rightarrow \\\\R$ always takes $>0$ values\\nthen $\\\\vec r$ and $\\\\vec s$ are said to be parameterizing $C$ in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"same orientation\"), \".\"), mdx(\"p\", null, \"When this is so,\"), mdx(\"p\", null, \"$$\\\\int_C \\\\vec F \\\\cdot d \\\\vec r = \\\\int_I \\\\vec F(\\\\vec r (t)) \\\\cdot \\\\vec r'(t) \\\\; dt$$\\n$$= \\\\int_I \\\\vec F(\\\\vec s(\\\\Phi(t))) \\\\cdot \\\\vec s'(\\\\Phi(t)) \\\\Phi'(t) \\\\; dt$$\\n$$= \\\\int_I \\\\vec F(\\\\vec s(u)) \\\\cdot \\\\vec s'(u) \\\\; ds$$\\n$$= \\\\int_C \\\\vec F \\\\cdot \\\\; ds$$\"), mdx(\"p\", null, \"If the orientation is negative, then we get exactly the negative of the above.\"), mdx(\"h1\", {\n    \"id\": \"integral-theorems\"\n  }, \"Integral Theorems\"), mdx(\"h2\", {\n    \"id\": \"fundamental-theorem-of-line-integrals\"\n  }, \"Fundamental Theorem of Line Integrals\"), mdx(\"p\", null, \"Let $C$ be a smooth curve in $\\\\R^n$, say from $A$ to $B$ given with a bijective smooth parameterization\\n$\\\\vec r : I \\\\rightarrow C$.\\nLet $D \\\\subseteq \\\\R^n$ be an open set with $C \\\\subseteq D$ and\\nlet $f: D \\\\rightarrow \\\\R$ be a continuously differentiable (scalar-valued) function.\\nThen\"), mdx(\"p\", null, \"$$ \\\\int_C \\\\nabla f \\\\cdot d \\\\vec r = f(B) - f(A)$$\"), mdx(\"p\", null, \"Note that this works for a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"piecewise smooth function\"), \" as well as the summation is telescopic.\"), mdx(\"h2\", {\n    \"id\": \"remarks-and-questions\"\n  }, \"Remarks and Questions\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Suppose we have to compute some line integral\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How do we know whether $\\\\vec F$ is a gradient vector field?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When we do know that $\\\\vec F$ is a gradient vector field, how do we find $f$ such that $\\\\vec F = \\\\nabla f$?\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If $\\\\vec F$ is a gradient vector field on an open set $D$, then for any smooth curve $C$ in $D$, $\\\\int_C F \\\\cdot d \\\\vec r$ depends only on the end points.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Any other smooth curve $C'$ will give the same answer.\")), mdx(\"h2\", {\n    \"id\": \"conservative-fields\"\n  }, \"Conservative Fields\"), mdx(\"p\", null, \"Let $\\\\vec F$ be a vector field defined on an open region $D$ in space,\\nand suppose that for any two points $A$ and $B$ in $D$ the line integral $\\\\int_C \\\\vec F \\\\cdot d \\\\vec r$ along a path $C$ from $A$ to $B$ in $D$ is the same over all paths from $A$ to $B$.\"), mdx(\"p\", null, \"Then the integral $\\\\int_C \\\\vec F \\\\cdot d \\\\vec r$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"path independent\"), \" in $D$ and the field $\\\\vec F$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"conservative\"), \" on $D$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If $\\\\vec F$ is a gradient vector field, then it is conservative\")), mdx(\"h2\", {\n    \"id\": \"connected-sets\"\n  }, \"Connected Sets\"), mdx(\"p\", null, \"A subset $X \\\\subseteq \\\\R^n$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"connected\"), \" iff for any open subsets $U, V$ of $\\\\R^n$ such that $U \\\\cap V \\\\cap X = \\\\varnothing$,\\none has $U \\\\cap X = \\\\phi$ or, $V \\\\cap X = \\\\varnothing$.\"), mdx(\"h3\", {\n    \"id\": \"proposition\"\n  }, \"Proposition\"), mdx(\"p\", null, \"Let $D \\\\subseteq \\\\R^n$ be an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"open\"), \" set.\"), mdx(\"p\", null, \"Then $D$ is connected iff $D$ is path connected ($D$ can be expressed as a piecewise smooth curve)\"), mdx(\"h2\", {\n    \"id\": \"loop-property-of-conservative-fields\"\n  }, \"Loop Property of Conservative Fields\"), mdx(\"p\", null, \"Let $D \\\\subseteq \\\\R^n$ be a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"connected\"), \" open set, $\\\\vec F : D \\\\rightarrow \\\\R^n$ be a continuous vector field on $D$.\"), mdx(\"p\", null, \"Then $\\\\vec F$ is conservative iff for any closed curve $C \\\\in D$,\\none has\"), mdx(\"p\", null, \"$$\\\\oint_c \\\\vec F \\\\cdot d \\\\vec r = 0$$\"), mdx(\"h2\", {\n    \"id\": \"criterion-for-gradient-vector-field\"\n  }, \"Criterion for Gradient Vector Field\"), mdx(\"p\", null, \"Component Test for Conservative Fields\"), mdx(\"p\", null, \"Let $D \\\\subseteq \\\\R^n$ be an open set,\\n$\\\\vec F : D \\\\rightarrow \\\\R^n$ be a continuously differentiable vector field on $D$.\"), mdx(\"p\", null, \"Write $\\\\vec F = (F_1, F_2, ..., F_n)$ with each $F_j : D \\\\rightarrow \\\\R$ a scalar valued function on $D$.\"), mdx(\"p\", null, \"If $\\\\vec F$ is a gradient vector field,\\nthen $\\\\forall i, j \\\\in \", \"{\", \"1, ..., n\", \"}\", \"$, one has\"), mdx(\"p\", null, \"$$\\\\frac{\\\\partial F_i}{\\\\partial x_j} = \\\\frac{\\\\partial F_j}{\\\\partial x_i}$$ \"), mdx(\"p\", null, \"on $D$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"will see that the converse holds whenever $D$ is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"connected\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"simply connected\"), \".\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"4ce7502b-53b0-5e11-9c79-95afa3750113","fields":{"slug":"/ma2104/line-integrals","title":"Line Integrals"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"surface-integrals\"\n  }, \"Surface Integrals\"), mdx(\"h2\", {\n    \"id\": \"surface-integral-of-scalar-valued-functions\"\n  }, \"Surface Integral of (scalar-valued) Functions\"), mdx(\"h3\", {\n    \"id\": \"parametrized-surface\"\n  }, \"Parametrized Surface\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parametrized surface\"), \" in $\\\\R^n$ is a function\\n$\\\\vec r : R \\\\rightarrow \\\\R^n$ from a region $R \\\\in \\\\R^2$ to Euclidean n-space $\\\\R^n$.\"), mdx(\"p\", null, \"The parametrized surface given by $\\\\vec r$ is \\\"smooth\\\" iff $\\\\vec r$ is continuously differentiable (partial derivatives components exists and are continuous)\"), mdx(\"h2\", {\n    \"id\": \"special-case-of-r3\"\n  }, \"Special case of $\\\\R^3$\"), mdx(\"p\", null, \"Let $S$ be a smooth surface in $\\\\R^3$.\"), mdx(\"p\", null, \"Let $G: S \\\\rightarrow \\\\R$ be a (scalar-valued) function on $S$.\"), mdx(\"p\", null, \"The surface integral of $G$ over $S$ is $\\\\int_S G \\\\; d\\\\sigma$ is defined as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Choose any \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"bijective smooth\"), \" parametrization $\\\\vec r : R \\\\rightarrow S$.\")), mdx(\"p\", null, \"$$\\\\int_S G \\\\; d \\\\sigma := \\\\int_R G (\\\\vec r(u, v)) \\\\vert \\\\vec r_u (u, v) \\\\times \\\\vec r_v (u, v) \\\\vert \\\\; d(u, v)$$\"), mdx(\"p\", null, \"(if the RHS exists)\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This is well-defined, independent of choice of parameter $\\\\vec r$\")), mdx(\"h3\", {\n    \"id\": \"additivity\"\n  }, \"Additivity\"), mdx(\"p\", null, \"If a piecewise smooth surface $S$ is obtained by joining a finite number of smooth surfaces $S_1, S_2, ..., S_n$ along boundary curves which are themselves piecewise smooth curves,\\nthen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"S f \\\\; d \\\\sigma = \\\\int\"), \"{S\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1} f \\\\; d \\\\sigma + ... + \\\\int\"), \"{S_n} f \\\\; d \\\\sigma$$\"), mdx(\"h2\", {\n    \"id\": \"surface-integral-of-a-vector-field\"\n  }, \"Surface Integral of a Vector Field\"), mdx(\"p\", null, \"$$\\\\int_S \\\\vec F \\\\cdot \\\\vec n \\\\; d \\\\sigma := \\\\int_R \\\\vec F(\\\\vec r (u, v)) \\\\cdot \\\\vec r_u (u, v) \\\\times \\\\vec r_v (u, v) \\\\; d(u, v)$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Make use of triple product, which gives us a scalar valued function that we can easily integrate iteratively over region $R$.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This depends on the chosen parameter $\\\\vec r$ of $S$ but only up to orientation.\")), mdx(\"p\", null, \"If $\\\\vec \\\\rho : \\\\Omega \\\\rightarrow S$ is another parameterization, then there exists some composed function $\\\\Phi$ that is continuously differentiable and invertible.\"), mdx(\"p\", null, \"If $J_\\\\Phi = det(\\\\Phi') : R \\\\rightarrow \\\\R$ always takes $>0$ values then $\\\\vec r$ and $\\\\vec p$ are said to be parametrizing $S$ in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"same orientation\"), \".\"), mdx(\"h3\", {\n    \"id\": \"the-normal-vector\"\n  }, \"The Normal Vector\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Comparable to the case of curves $\\\\int_C \\\\vec F \\\\cdot \\\\vec T \\\\; ds$\")), mdx(\"p\", null, \"The normal vector $\\\\vec n$ is a unit vector on the positive side of the surface defined by parameterization.\\nSetting $\\\\vec n(p)$ as the normalized $\\\\vec r_u(u, v) \\\\times \\\\vec r_v(u, v)$.\"), mdx(\"p\", null, \"$$ \\\\vec n (p) := \\\\frac{\\\\vec r_u (u, v) \\\\times \\\\vec r_v (u, v)}{\\\\vert \\\\vec r_u (u, v) \\\\times \\\\vec r_v (u, v) \\\\vert}$$\"), mdx(\"h3\", {\n    \"id\": \"flow-and-flux\"\n  }, \"Flow and Flux\"), mdx(\"p\", null, \"In terminology, flux of $\\\\vec F$ is a surface integral\"), mdx(\"p\", null, \"and flow of $\\\\vec F$ over $C$ is a curve integral.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"a5f96dd9-3e03-58ce-a9ab-52dc0e2809cc","fields":{"slug":"/ma2104/surface-integrals","title":"Surface Integrals"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"curl-of-vector-field\"\n  }, \"Curl of Vector Field\"), mdx(\"p\", null, \"Curl is a differentiation of a vector field that gets another vector field.\"), mdx(\"p\", null, \"Let $U \\\\subseteq \\\\R^3$ be an open set in $\\\\R^3$.\\nand $\\\\vec F : U \\\\rightarrow \\\\R^3$ be a differentiable vector field.\"), mdx(\"p\", null, \"The curl of $\\\\vec F$ is the vector field $\\\\nabla \\\\times \\\\vec F : U \\\\rightarrow \\\\R^3$ given by for each $\\\\vec p \\\\in U$, \"), mdx(\"p\", null, \"$$(\\\\nabla \\\\times \\\\vec F)(\\\\vec p) := \\\\begin{pmatrix}\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"\\\\frac{\\\\partial P}{\\\\partial y}(\\\\vec p) - \\\\frac{\\\\partial N}{\\\\partial z}(\\\\vec p) \", \"\\\\\", \"\\n\\\\frac{\\\\partial M}{\\\\partial z}(\\\\vec p) - \\\\frac{\\\\partial P}{\\\\partial x}(\\\\vec p) \", \"\\\\\", \"\\n\\\\frac{\\\\partial N}{\\\\partial x}(\\\\vec p) - \\\\frac{\\\\partial M}{\\\\partial y}(\\\\vec p) \", \"\\\\\", \"\\n\\\\end{pmatrix}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Take $\\\\nabla = \\\\partial / (\\\\partial x, \\\\partial y, \\\\partial z)$ and do a cross product.\")), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"curl vector field\"), \" on $U$ is a vector field $\\\\vec G : U \\\\rightarrow \\\\R^3$ such that there exists a differentiable vector field $\\\\vec F : U \\\\rightarrow \\\\R^3$ such that $\\\\vec G = \\\\nabla \\\\times \\\\vec F$.\"), mdx(\"p\", null, \"When this is so, the vector field $\\\\vec F$ is called a vector potential of $\\\\vec G$.\"), mdx(\"h2\", {\n    \"id\": \"algebraic-rules-for-curls\"\n  }, \"Algebraic Rules for Curls\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sum rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Difference rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Constant multiple rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Product rule \", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\nabla \\\\times (f \\\\vec F) = f \\\\nabla \\\\times \\\\vec F + \\\\nabla f \\\\times \\\\vec F$\")))), mdx(\"h2\", {\n    \"id\": \"important-identity\"\n  }, \"Important Identity\"), mdx(\"p\", null, \"Let $U \\\\subseteq \\\\R^3$ be an open set in $\\\\R^3$\\nand $f: U \\\\rightarrow \\\\R$ be a twice continuously differentiable scalar-valued function on $U$.\"), mdx(\"p\", null, \"Then $\\\\nabla \\\\times (\\\\nabla f) = 0$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If $\\\\vec F$ is a gradient vector field, then $\\\\nabla \\\\times \\\\vec F = \\\\vec 0$\")), mdx(\"h2\", {\n    \"id\": \"stokes-theorem\"\n  }, \"Stoke's Theorem\"), mdx(\"h3\", {\n    \"id\": \"key-theorem-2\"\n  }, \"Key Theorem 2\"), mdx(\"p\", null, \"Let $S$ be a smooth surface in $\\\\R^3$,\\ngiven a smooth bijective parameterization.\"), mdx(\"p\", null, \"$$\\\\vec r : R \\\\rightarrow S$$\"), mdx(\"p\", null, \"where $R \\\\subseteq \\\\R^2$ is a compact rectangle\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The boundary $\\\\partial S$ of $S$ is then a piecewise smooth curve parameterized by the restriction of $\\\\vec r$ to the boundary $\\\\partial R$ of $R$.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Regard $\\\\partial R$ as a piecewise smooth (closed) curve in $\\\\R^2$ oriented counterclockwise.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This induces corresponding orientation on $\\\\partial S$.\")), mdx(\"h4\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"First prove the special case of Green's Theorem\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then reduce the general case of Stoke's Theorem to the special case of Green's Theorem\")), mdx(\"hr\", null), mdx(\"p\", null, \"Let $D \\\\subseteq \\\\R^3$ be an open set with $S \\\\subseteq D$\\nand let $\\\\vec F : D \\\\rightarrow \\\\R^3$ be a continuously differentiable vector field.\\nThen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"S (\\\\nabla \\\\times \\\\vec F) \\\\cdot \\\\vec n \\\\; d \\\\sigma = \\\\int\"), \"{\\\\partial S} \\\\vec F \\\\cdot d \\\\vec r = \\\\int_{\\\\partial S} \\\\vec F \\\\cdot \\\\vec T \\\\; ds$$\"), mdx(\"p\", null, \"If 2 different oriented surfaces have the same boundary, their curl integrals are equal.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Stoke's Theorem also holds for oriented surfaces with holes\")), mdx(\"h2\", {\n    \"id\": \"greens-theorem\"\n  }, \"Green's Theorem\"), mdx(\"p\", null, \"Let $C$ be a piecewise smooth, simple closed curve enclosing a region $R$ in the plane.\\nLet $\\\\vec F = M \\\\vec i + N \\\\vec j$ be a vector field with $M$ and $N$ having continuous first partial derivatives in an open region containing $R$.\\nThen the counterclockwise circulation of $\\\\vec F$ around $C$ equals the double integral of $(\\\\nabla \\\\times \\\\vec F) \\\\cdot \\\\vec k$ over $R$.\"), mdx(\"p\", null, \"$$\\\\oint_C \\\\vec F \\\\cdot T \\\\; ds = \\\\oint_C M \\\\; dx + N \\\\; dy = \\\\iint_R \\\\Bigg(\\\\frac{\\\\partial N}{\\\\partial x} - \\\\frac{\\\\partial M}{\\\\partial y} \\\\Bigg ) \\\\; dx \\\\; dy$$\"), mdx(\"h1\", {\n    \"id\": \"divergence\"\n  }, \"Divergence\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"divergence-of-vector-fields\",\n    \"title\": \"Divergence of a Vector Field\"\n  }, \"divergence-of-vector-fields\"), \"]\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"8a89f3f8-b800-5421-9262-e7cd18591685","fields":{"slug":"/ma2104/curl-of-vector-field","title":"Curl of Vector Field"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"divergence-of-a-vector-field\"\n  }, \"Divergence of a Vector Field\"), mdx(\"p\", null, \"Let $U \\\\subseteq \\\\R^n$ be an open set in $\\\\R^n$\"), mdx(\"p\", null, \"and $\\\\vec F : U \\\\rightarrow \\\\R^n$ be a differentiable vector field,\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"divergence of\"), \" $\\\\vec F$ is the (scalar) function $\\\\nabla \\\\cdot \\\\vec F \\\\rightarrow \\\\R$ given by\"), mdx(\"p\", null, \"$$\\\\nabla \\\\cdot \\\\vec F = \\\\frac{\\\\partial F_1}{\\\\partial x_1} + ... + \\\\frac{\\\\partial F_n}{\\\\partial x_n}$$\"), mdx(\"p\", null, \"Thus $\\\\nabla \\\\cdot \\\\vec F$ is a function on $U$ is continuous iff $\\\\vec F$ is continuously differentiable.\"), mdx(\"h2\", {\n    \"id\": \"algebraic-rules-for-divergence\"\n  }, \"Algebraic Rules for Divergence\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sum Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Difference Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Constant multiple Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Product Rule $\\\\nabla \\\\cdot (f \\\\vec F) = f(\\\\nabla \\\\cdot \\\\vec F) + (\\\\nabla f) \\\\cdot \\\\vec F$\")), mdx(\"h2\", {\n    \"id\": \"divergence-of-curl\"\n  }, \"Divergence of Curl\"), mdx(\"p\", null, \"If $\\\\vec F$ is a twice continuously differentiable vector field in $\\\\R^3$, then\"), mdx(\"p\", null, \"$$\\\\nabla \\\\cdot (\\\\nabla \\\\times \\\\vec F) = 0$$\"), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"Expand components.\"), mdx(\"h2\", {\n    \"id\": \"corollary-condition-for-curl\"\n  }, \"Corollary Condition for Curl\"), mdx(\"p\", null, \"If $\\\\vec F$ is a curl vector field, \"), mdx(\"p\", null, \"then $\\\\nabla \\\\cdot \\\\vec F = 0$\"), mdx(\"p\", null, \"Since $\\\\vec F = \\\\nabla \\\\times \\\\vec G$ implies $\\\\nabla \\\\cdot \\\\vec F = \\\\nabla \\\\cdot (\\\\nabla \\\\times \\\\vec G) = 0$\"), mdx(\"h2\", {\n    \"id\": \"divergence-theorem\"\n  }, \"Divergence Theorem\"), mdx(\"p\", null, \"Let $D$ be a compact region in $\\\\R^3$,\\nwhose boundary $\\\\partial D$ is a piecewise smooth surface.\"), mdx(\"p\", null, \"Let $\\\\vec F : D \\\\rightarrow \\\\R^3$ be a continuously differentiable vector field on $D$.\\nThen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"D (\\\\nabla \\\\cdot \\\\vec F) \\\\; dV = \\\\oint\"), \"{\\\\partial D} \\\\vec F \\\\cdot \\\\vec n \\\\; d \\\\sigma$$\"), mdx(\"p\", null, \"where the boundary $\\\\partial D$ is oriented with the unit normal vector field $\\\\vec n$ pointing outwards.\"), mdx(\"h3\", {\n    \"id\": \"proof-1\"\n  }, \"Proof\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"h3\", {\n    \"id\": \"divergence-theorem-in-r2\"\n  }, \"Divergence Theorem in $\\\\R^2$\"), mdx(\"p\", null, \"Let $D$ be a compact region in $\\\\R^2$,\\nwhose boundary $\\\\partial D$ is a piecewise smooth curve.\"), mdx(\"p\", null, \"Let $\\\\vec F : D \\\\rightarrow \\\\R^2$ be a continuously differentiable vector field on $D$.\\nThen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"R (\\\\nabla \\\\cdot \\\\vec F) \\\\; d(x, y) = \\\\oint\"), \"{\\\\partial R} \\\\vec F \\\\cdot \\\\vec n \\\\; ds$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"391b03b8-5494-5844-ab95-0781fe1e7d60","fields":{"slug":"/ma2104/divergence-of-vector-fields","title":"Divergence of a Vector Field"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"extreme-values\"\n  }, \"Extreme Values\"), mdx(\"p\", null, \"Basic Facts\"), mdx(\"p\", null, \"Let $R \\\\subseteq \\\\R^n$ be a region in Euclidean space\"), mdx(\"p\", null, \"Let $f: R \\\\rightarrow \\\\R$ be a function\"), mdx(\"p\", null, \"If $R$ is compact (close & bounded) and $f$ is continuous\\nthen there exists $p \\\\in \\\\R$ such that\\n$f(p)$ is the global maximum value of $f$ over $R$.\"), mdx(\"h2\", {\n    \"id\": \"local-maximum\"\n  }, \"Local Maximum\"), mdx(\"p\", null, \"Let $f(x, y)$ be defined on a region $R$ containing the point $(a, b)$.\\nThen\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f(a, b)$ is a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"local maximum\"), \" value of $f$ if $f(a, b) \\\\geq f(x, y)$ for all domain points $(x, y)$ in an open disk centered at $(a, b)$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f(a, b)$ is a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"local minimum\"), \" value of $f$ if $f(a, b) \\\\leq f(x, y)$ for all domain points $(x, y)$ in an open disk centered at $(a, b)$.\")), mdx(\"p\", null, \"$p \\\\in R$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"local maximum point\"), \" for $f$ iff\"), mdx(\"p\", null, \"$\\\\exists \\\\epsilon \\\\in \\\\R_{> 0}$ s.t. $\\\\forall q \\\\in R$ with $\\\\vert q - p \\\\vert < \\\\epsilon$, one has $f(q) \\\\leq f(p)$.\"), mdx(\"p\", null, \"When this is so, $f(p) \\\\in \\\\R$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"local maximum value\"), \" of $f$.\"), mdx(\"h2\", {\n    \"id\": \"first-derivative-test-for-local-extreme-values\"\n  }, \"First Derivative Test for Local Extreme Values\"), mdx(\"p\", null, \"Suppose $f: R \\\\rightarrow \\\\R$ is differentiable and $p \\\\in R$ is an interior point of $R$ which is local max/min point of $f$.\\nThen\"), mdx(\"p\", null, \"$$(\\\\nabla f)(\\\\vec p) = \\\\vec 0$$\"), mdx(\"h2\", {\n    \"id\": \"critical-point\"\n  }, \"Critical Point\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"critical point\"), \" of $f: R \\\\rightarrow \\\\R$ is an interior point $p \\\\in R$ of $R$ such that \"), mdx(\"p\", null, \"$$(\\\\nabla f)(\\\\vec p) = \\\\vec 0$$\"), mdx(\"p\", null, \"when this is so, $f(p) \\\\in \\\\R$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"critical value\"), \" of $f$\"), mdx(\"p\", null, \"Thus, by the first derivative test, all local max/min points of $f$ which are interior points of $R$ must be among the critical points of $f$.\"), mdx(\"h2\", {\n    \"id\": \"absolute-maxima-and-minima-on-closed-bounded-regions\"\n  }, \"Absolute Maxima and Minima on Closed Bounded Regions\"), mdx(\"p\", null, \"We organize the search for the absolute extrema of a continuous function $f(x, y)$ on a closed bounded region $R$ into 3 steps\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"List the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"interior points\"), \" of $R$ where $f$ may have local maxima and minima and evaluate $f$ at these points. These are the critical points of $f$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"List the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"boundary points\"), \" of $R$ where $f$ has local maxima and minima and evaluate $f$ at these points.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Look through the lists for the maximum and minimum values of $f$. These will be the absolute maximum and minimum values of $f$ on $R$.\")), mdx(\"h2\", {\n    \"id\": \"saddle-point\"\n  }, \"Saddle Point\"), mdx(\"p\", null, \"$p \\\\in R$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"saddle point\"), \" for $f$ iff\\n$p$ is a critical point for $f$ but $p$ is not a local maximum and local minimum for $f$.\"), mdx(\"h2\", {\n    \"id\": \"second-derivative-test-for-local-extreme-values\"\n  }, \"Second Derivative Test for Local Extreme Values\"), mdx(\"p\", null, \"Suppose that $f(x, y)$ and its first and second derivatives are continuous throughout a disk centered at $(a, b)$ and that $f_x(a, b) = f_y(a, b) = 0$.\\nThen\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f$ has a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"local maximum\"), \" at $(a, b)$ if $f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{xx} < 0$ and $f\"), \"{xx}f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{yy} - f\"), \"{xy}^2 > 0$ at $(a, b)$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f$ has a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"local minimum\"), \" at $(a, b)$ if $f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{xx} > 0$ and $f\"), \"{xx}f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{yy} - f\"), \"{xy}^2 > 0$ at $(a, b)$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f$ has a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"saddle point\"), \" at $(a, b)$ if $f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{xx}f\"), \"{yy} - f_{xy}^2 < 0$ at $(a, b)$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"test is inconclusive\"), \" at $(a, b)$ if $f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{xx}f\"), \"{yy} - f_{xy}^2 = 0$ at $(a, b)$. In this case, we must find some other way to determine the behavior of $f$ at $(a, b)$.\")), mdx(\"h3\", {\n    \"id\": \"hessian\"\n  }, \"Hessian\"), mdx(\"p\", null, \"Determinant of square matrix of partial derivatives.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"65098e40-f3d2-5a96-b776-9a5c66db4286","fields":{"slug":"/ma2104/extreme-values","title":"Extreme Values"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"maxwell-equations\"\n  }, \"Maxwell Equations\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$$\\\\oint\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"S \\\\vec E \\\\circ \\\\hat n \\\\; ds = \\\\frac{q\"), \"{enc}}{\\\\epsilon_0}$$\")), mdx(\"p\", null, \"Electric charge produces an electric field, and the flux of that field passing through any closed surface is proportional to the total charge contained within that surface.\"), mdx(\"p\", null, \"$S = \\\\partial D$ is a closed surface\"), mdx(\"p\", null, \"$q_{enc}$ is the total amount of charge contained within that surface\"), mdx(\"p\", null, \"$e_0$ is the permittivity of free space\"), mdx(\"p\", null, \"$\\\\vec E$ is the electric field, the electrical force per unit charge exerted on a charged object.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"3f52094b-a3a6-5821-ba68-8057beee3642","fields":{"slug":"/ma2104/maxwell-equations","title":"Maxwell Equations"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"bubble-foader\"\n  }, \"Bubble Foader\"), mdx(\"p\", null, \"#entry\"), mdx(\"p\", null, \"\\uD83D\\uDC4B Welcome to my Foam Knowledge Base!\"), mdx(\"h2\", {\n    \"id\": \"navigation\"\n  }, \"Navigation\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"dingyuchen.github.io\"\n  }, \"blog\"), \" - This is where I keep my blog\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"inbox\",\n    \"title\": \"Inbox\"\n  }, \"inbox\"), \"] - a place to write down quick notes to be categorised later\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"] - a place to keep track of things I want/need to do\")), mdx(\"h3\", {\n    \"id\": \"modules\"\n  }, \"Modules\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"cs5330/module-5330\",\n    \"title\": \"Randomized Algorithms\"\n  }, \"module-5330\"), \"] - CS5330 Randomized Algorithms\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"distributed-dyom/distributed-dyom\",\n    \"title\": \"Distributed Systems\"\n  }, \"distributed-dyom\"), \"] - DYOM Distributed Systems\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"st2131/module-2131\",\n    \"title\": \"Probability\"\n  }, \"module-2131\"), \"] - ST2131 Probability\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ma3110/module-ma3110\",\n    \"title\": \"Mathematical Analysis 2\"\n  }, \"module-ma3110\"), \"] - MA3110 Mathematical Analysis 2\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ma2101/module-ma2101\",\n    \"title\": \"Linear Algebra 2\"\n  }, \"module-ma2101\"), \"] - MA2101 Linear Algebra 2\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ma2104/module-ma2104\",\n    \"title\": \"Multivariable Calculus\"\n  }, \"module-ma2104\"), \"] - MA2104 Multivariable Calculus\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ma3252/module-ma3252\",\n    \"title\": \"Linear and Network Optimization\"\n  }, \"module-ma3252\"), \"] - MA3252 Linear and Network Optimization\")), mdx(\"h3\", {\n    \"id\": \"other-collections\"\n  }, \"Other Collections\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"misc/misc\",\n    \"title\": \"Miscellaneous\"\n  }, \"misc\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"making-your-own\"\n  }, \"Making your own\"), mdx(\"p\", null, \"This documentation assumes that you have a GitHub account and have \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://code.visualstudio.com/\"\n  }, \"Visual Studio Code\"), \" installed on your Linux/MacOS/Windows machine.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If you haven't yet, browse over to the main \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://foambubble.github.io/foam\"\n  }, \"Foam documentation workspace\"), \" to get an idea of what Foam is and how to use it.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Press \\\"Use this template\\\" button at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/mathieudutour/foam-gatsby-template/generate\"\n  }, \"foam-gatsby-template\"), \" to fork it to your own GitHub account. If you want to keep your thoughts to yourself, remember to set the repository private.\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"This creates a gatsby template instead of the vanilla one used by Foam. It supports backlinking and graph out of the box.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Unfortunately, it does not allow nested subfolders (pending PR merge) and latex.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://help.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository\"\n  }, \"Clone the repository to your local machine\"), \" and open it in VS Code.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Open the repository as a folder using the \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"File > Open...\"), \" menu item.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"When prompted to install recommended extensions, click \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Install all\"), \" (or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Show Recommendations\"), \" if you want to review and install them one by one)\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Open \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"_layouts/gatsby-config.js\"\n  }, \"_layouts/gatsby-config.js\"), \" and edit the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pathPrefix\"), \" to be the name of the repository.\"))), mdx(\"p\", null, \"After setting up the repository, head to [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"getting-started\",\n    \"title\": \"Getting Started\"\n  }, \"getting-started\"), \"] to get familiar with your new knowledge base!\"), mdx(\"p\", null, \"To learn more about how to use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Foam\"), \", read the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://foambubble.github.io/foam/recipes/recipes\"\n  }, \"Recipes\"), \" bubbles of the Foam documentation workspace.\"), mdx(\"p\", null, \"And remember that you can always join our  \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://discord.gg/HV2tn2FpEk\"\n  }, \"Foam community on Discord\"), \"!\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"b97941cc-9f81-5bf4-85d9-dcd0172036fd","fields":{"slug":"/readme","title":"Bubble Foader"}}}]},"fields":{"slug":"/ma2104/module-ma2104","title":"Multivariable Calculus"}}},"pageContext":{"id":"4667b8ff-5878-5615-8823-9a1a640cc0db"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}