{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/ma2104/module-ma2104","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"multivariable-calculus\"\n  }, \"Multivariable Calculus\"), mdx(\"p\", null, \"#entry\"), mdx(\"h2\", {\n    \"id\": \"module-information\"\n  }, \"Module Information\"), mdx(\"p\", null, \"Lectures will be pre-recorded and uploaded every Tuesday and Friday before 12pm in multimedia.\"), mdx(\"p\", null, \"Focus of the lectures will be on the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"mathematical concepts and proofs\"), \".\"), mdx(\"p\", null, \"Tutorials will alternate between \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lecture on a topic\"), \" (part of tested materials) and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"discussion of the homework problems\"), \".\"), mdx(\"p\", null, \"Tutorials are also pre-recorded and uploaded on Luminus before Wednesday, 2pm.\"), mdx(\"h2\", {\n    \"id\": \"assessment\"\n  }, \"Assessment\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Test\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Weightage\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"5x Homework\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"40%\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Finals\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"60%\")))), mdx(\"h2\", {\n    \"id\": \"textbook\"\n  }, \"Textbook\"), mdx(\"p\", null, \"Thomas, Calculus, 14th ed., - Hass, Heil & Weir\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Chapters 11 - 16\")), mdx(\"h2\", {\n    \"id\": \"table-of-contents\"\n  }, \"Table of Contents\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"euclidean-spaces\",\n    \"title\": \"Euclidean Spaces\"\n  }, \"euclidean-spaces\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"curves\",\n    \"title\": \"Curves in $\\\\R^n$\"\n  }, \"curves\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"multivariable-functions\",\n    \"title\": \"Multivariable Functions\"\n  }, \"multivariable-functions\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"higher-order-derivatives\",\n    \"title\": \"Higher Order Derivatives\"\n  }, \"higher-order-derivatives\"), \"] \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"multivariable-integration\",\n    \"title\": \"Multivariable Integration\"\n  }, \"multivariable-integration\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"integration-by-substitution\",\n    \"title\": \"Integration by Substitution\"\n  }, \"integration-by-substitution\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"line-integrals\",\n    \"title\": \"Line Integrals\"\n  }, \"line-integrals\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"surface-integrals\",\n    \"title\": \"Surface Integrals\"\n  }, \"surface-integrals\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"curl-of-vector-field\",\n    \"title\": \"Curl of Vector Field\"\n  }, \"curl-of-vector-field\"), \"] \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"divergence-of-vector-fields\",\n    \"title\": \"Divergence of a Vector Field\"\n  }, \"divergence-of-vector-fields\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"extreme-values\",\n    \"title\": \"Extreme Values\"\n  }, \"extreme-values\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"maxwell-equations\",\n    \"title\": \"Maxwell Equations\"\n  }, \"maxwell-equations\"), \"]\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"euclidean-spaces\"\n  }, \"Euclidean Spaces\"), mdx(\"p\", null, \"Fix a natural number $n \\\\in \\\\N$.\"), mdx(\"p\", null, \"Set $\\\\R^n := \\\\R \\\\times \\\\R \\\\times ... \\\\times \\\\R :=$ { all ordered $n$-tuples }\\ncalled the standard ($n$-dimensional) vector space (over $\\\\R$)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$n$ is called the dimension of $\\\\R^n$\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"elements of $\\\\R^n$ are called vectors, points, $n$-tuples\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"elements of $\\\\R$ are called scalars\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if $\\\\vec \\\\mathbf{u} \\\\in \\\\R^n$ is a vector,\\nthen for each $i = 1, ..., n$, we call $u_i$ the $i^{th}$ component\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the vector $\\\\vec 0 := (0, ..., 0)$ is the zero vector (origin)\")), mdx(\"h2\", {\n    \"id\": \"vectors\"\n  }, \"Vectors\"), mdx(\"h3\", {\n    \"id\": \"operations-on-vectors\"\n  }, \"Operations on Vectors\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Addition \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"add vectors componentwise\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Negation\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"apply distributively\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Scalar multiplication\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"apply distributively\")))), mdx(\"h2\", {\n    \"id\": \"dot-product\"\n  }, \"Dot Product\"), mdx(\"p\", null, \"$( \\\\cdot ) : \\\\R^n \\\\times \\\\R^n \\\\rightarrow \\\\R$\"), mdx(\"p\", null, \"$$\\\\vec u \\\\cdot \\\\vec v = \\\\sum^n_{i = 1} u_i v_i$$\"), mdx(\"h3\", {\n    \"id\": \"properties-of-dot-product\"\n  }, \"Properties of Dot Product\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Symmetric\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Commutative\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Associative w.r.t. scalar multiplication\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Distributive\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec u \\\\cdot \\\\vec u = \\\\vert \\\\vec u \\\\vert ^2$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec 0 \\\\cdot \\\\vec u = 0$\")), mdx(\"hr\", null), mdx(\"p\", null, \"Standard (n-dimensional) Euclidean space\\n: $\\\\R^n$ given with its vector space operations (+, -, scalar multiplication) and its dot product\"), mdx(\"hr\", null), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Any $\\\\vec u \\\\cdot \\\\vec u$ is always $\\\\geq 0$.\")), mdx(\"h3\", {\n    \"id\": \"length\"\n  }, \"Length\"), mdx(\"p\", null, \"$$\\\\vert \\\\vec u \\\\vert := \\\\sqrt{\\\\vec u \\\\cdot \\\\vec u}$$\"), mdx(\"h4\", {\n    \"id\": \"properties-of-vector-lengths\"\n  }, \"Properties of Vector Lengths\"), mdx(\"p\", null, \"If $\\\\vec u$ and $\\\\vec v$ are any vector and $c$ is a scalar, then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vert \\\\vec u \\\\vert  = 0$ iff $\\\\vec u = \\\\vec 0$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vert c \\\\vec u \\\\vert = \\\\vert c \\\\vert \\\\vert \\\\vec u \\\\vert$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vert \\\\vec u + \\\\vec v \\\\vert  \\\\leq  \\\\vert \\\\vec u \\\\vert  +  \\\\vert \\\\vec v \\\\vert$\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"3 follows [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"triangle-inequality\",\n    \"title\": \"Triangle Inequality\"\n  }, \"triangle-inequality\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"unit-vectors\"\n  }, \"Unit Vectors\"), mdx(\"p\", null, \"Any vector with length $1$ is a unit vector\"), mdx(\"hr\", null), mdx(\"p\", null, \"Standard unit vector\\n: vector with 1 in some component and 0 in all others\"), mdx(\"hr\", null), mdx(\"h3\", {\n    \"id\": \"proposition\"\n  }, \"Proposition\"), mdx(\"p\", null, \"Any vector in $\\\\R^n$ is a linear combination of the standard unit vectors.\"), mdx(\"h3\", {\n    \"id\": \"direction-vectors\"\n  }, \"Direction Vectors\"), mdx(\"p\", null, \"If $\\\\vec v \\\\neq 0$ then $\\\\frac{\\\\vec v}{  \\\\vert \\\\vec v \\\\vert  }$ is called the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"direction\"), \" of the vector $\\\\vec v$.\"), mdx(\"h3\", {\n    \"id\": \"angle\"\n  }, \"Angle\"), mdx(\"p\", null, \"The angle between 2 nonzero vectors $\\\\vec u$ and $\\\\vec v$ is $\\\\theta = \\\\cos^{-1}(\\\\frac{\\\\vec u \\\\cdot \\\\vec v}{\\\\vert \\\\vec u \\\\vert \\\\vert \\\\vec v \\\\vert })$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This has meaning because of [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"cauchy-schwarz-inequality\",\n    \"title\": \"Cauchy-Schwarz Inequality\"\n  }, \"cauchy-schwarz-inequality\"), \"] which restricts the possible values of $\\\\cos \\\\theta$.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Vectors $\\\\vec u$ and $\\\\vec v$ are orthogonal if $\\\\vec u \\\\cdot \\\\vec v = 0$.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The scalar component of $\\\\vec u$ in the direction of $\\\\vec v$ is the scalar\\n$$\\\\vert \\\\vec u \\\\vert  \\\\cos \\\\theta = \\\\frac{\\\\vec u \\\\cdot \\\\vec v}{ \\\\vert \\\\vec v \\\\vert } = \\\\vec u \\\\cdot \\\\frac{\\\\vec v}{ \\\\vert \\\\vec v \\\\vert }$$\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$\\\\vec u$ dot product with unit direction vector of $\\\\vec v$\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The vector projection of $\\\\vec u$ onto $\\\\vec v$ is the vector\\n$$\\\\text{proj}_v \\\\vec u = (\\\\frac{\\\\vec u \\\\cdot \\\\vec v}{ \\\\vert \\\\vec v \\\\vert ^2}) \\\\vec v = (\\\\frac{\\\\vec u \\\\cdot \\\\vec v}{ \\\\vert \\\\vec v \\\\vert }) \\\\frac{\\\\vec v}{ \\\\vert \\\\vec v \\\\vert }$$\")), mdx(\"h2\", {\n    \"id\": \"cross-product\"\n  }, \"Cross Product\"), mdx(\"h3\", {\n    \"id\": \"cross-product-on-r3\"\n  }, \"Cross Product on $\\\\R^3$\"), mdx(\"p\", null, \"$( \\\\times ) : \\\\R^3 \\\\times \\\\R^3 \\\\rightarrow \\\\R^3$\"), mdx(\"p\", null, \"$$\\\\vec u \\\\times \\\\vec v = ( \\\\vert \\\\vec u \\\\vert |\\\\vec v \\\\vert  \\\\sin \\\\theta) \\\\vec n$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The magnitude of the normal vector is the area parallelogram formed by the 2 vectors\")), mdx(\"h4\", {\n    \"id\": \"cross-product-of-standard-vectors\"\n  }, \"Cross Product of Standard Vectors\"), mdx(\"p\", null, \"$$\\\\vec i \\\\times \\\\vec j = \\\\vec k$$\\n$$\\\\vec j \\\\times \\\\vec k = \\\\vec i$$\\n$$\\\\vec k \\\\times \\\\vec i = \\\\vec j$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"RHS follows a cyclic pattern (i-j-k)\")), mdx(\"h4\", {\n    \"id\": \"properties-of-the-cross-product\"\n  }, \"Properties of the Cross Product\"), mdx(\"p\", null, \"If $\\\\vec u$, $\\\\vec v$ and $\\\\vec w$ are any vectors and $r, s$ are scalars, then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$(r \\\\vec u) \\\\times (s \\\\vec v) = (rs) (\\\\vec u \\\\times \\\\vec v)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec u \\\\times (\\\\vec v + \\\\vec w) = \\\\vec u \\\\times \\\\vec v + \\\\vec u \\\\times \\\\vec w$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec v \\\\times \\\\vec u = -(\\\\vec u \\\\times \\\\vec v)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$(\\\\vec v + \\\\vec w) \\\\times \\\\vec u = \\\\vec v \\\\times \\\\vec u + \\\\vec w \\\\times \\\\vec u$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\vec 0 \\\\times \\\\vec u = \\\\vec 0$\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"triple-product-formula\",\n    \"title\": \"Triple Product Formula\"\n  }, \"triple-product-formula\"), \"]\")), mdx(\"hr\", null), mdx(\"h4\", {\n    \"id\": \"proposition-1\"\n  }, \"Proposition\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For any $\\\\vec u, \\\\vec v \\\\in \\\\R^3$ one has $(\\\\vec u \\\\times \\\\vec v) \\\\cdot \\\\vec u = \\\\vec 0 = (\\\\vec u \\\\times \\\\vec v) \\\\cdot \\\\vec v$\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"and if $\\\\vec u$ and $\\\\vec v$ are both $\\\\neq \\\\vec 0$, $\\\\vert \\\\vec u \\\\times \\\\vec v \\\\vert ^2 =  \\\\vert \\\\vec u \\\\vert ^2  \\\\vert \\\\vec v \\\\vert ^2 \\\\sin^2 \\\\theta$\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$(\\\\vec u \\\\times \\\\vec v)$ is always orthogonal to both $\\\\vec u$ and $\\\\vec v$.\")), mdx(\"h4\", {\n    \"id\": \"lines-and-planes\"\n  }, \"Lines and Planes\"), mdx(\"p\", null, \"A vector equation for the line $L$, through $P_0(x_0, y_0, z_0)$ parallel to $\\\\vec v$ is\\n$$\\\\vec r(t) = \\\\vec r_0 + r \\\\vec v$$\"), mdx(\"p\", null, \"Extending the components, we get the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parametric equations for a line\"), \".\"), mdx(\"p\", null, \"$$x = x_0 + tv_1, y = y_0 + tv_2, z = z_0 + tv_3$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note that the parameterization are not unique.\\nYou can choose any scalar multiple for $\\\\vec v$ or different \\\"starting point\\\".\")), mdx(\"h5\", {\n    \"id\": \"distance-from-a-point-s-to-a-line-through-p-parallel-to-v\"\n  }, \"Distance from a Point $S$ to a Line Through $P$ parallel to $v$\"), mdx(\"p\", null, \"$$d = \\\\frac{\\\\vert \\\\vec{PS} \\\\times \\\\vec v \\\\vert}{\\\\vert \\\\vec v \\\\vert}$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"02531be3-5813-56f5-a390-11209663b616","fields":{"slug":"/ma2104/euclidean-spaces","title":"Euclidean Spaces"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"curves-in-rn\"\n  }, \"Curves in $\\\\R^n$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We won't be able to define what a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"curve\"), \" is until we have developed some necessary tools about differentiation and derivatives.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"3 usual ways of giving a curve:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"parameterized curve\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"graph of a function\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"level set of function(s)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For these descriptions to give a valid curve, some technical conditions have to be imposed on the inputs\")), mdx(\"h2\", {\n    \"id\": \"a-parameterized-curve-in-rn\"\n  }, \"A Parameterized Curve in $\\\\R^n$\"), mdx(\"p\", null, \"is a function\"), mdx(\"p\", null, \"$\\\\vec r : I \\\\rightarrow \\\\R^n$ from an interval $I \\\\subseteq \\\\R^1$ to Euclidean n-space $\\\\R^n$\"), mdx(\"p\", null, \"The domain $I$ is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parameter interval\"), \".\"), mdx(\"p\", null, \"The image $\\\\vec r(I)$ of the function $\\\\vec r$ is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"curve\"), \".\"), mdx(\"p\", null, \"The variable $t$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parameter\"), \" for the curve.\"), mdx(\"p\", null, \"For any $t \\\\in I$, $\\\\vec r(t)$ is a vector in $\\\\R^n$,\\ncan be written in component form and the function $\\\\vec r : I \\\\rightarrow \\\\R^n$ is the same as giving $n$ many single variable functions.\"), mdx(\"p\", null, \"If $I$ is a closed interval $a \\\\leq t \\\\leq b$,\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$\\\\vec r(a)$ is the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"initial point\"), \" of the curve\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"$\\\\vec r(b)$ is the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"terminal point\"), \" of the curve\")), mdx(\"h2\", {\n    \"id\": \"limits-and-continuity\"\n  }, \"Limits and Continuity\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"limits-and-continuity\",\n    \"title\": \"Limits and Continuity\"\n  }, \"limits-and-continuity\"), \"]\"), mdx(\"h3\", {\n    \"id\": \"proposition\"\n  }, \"Proposition\"), mdx(\"p\", null, \"Suppose $\\\\vec r : I \\\\rightarrow \\\\R^n$ is given in component form:\"), mdx(\"p\", null, \"$$\\\\vec r(t) = (r_1(t), r_2(t), ..., r_n(t))$$\"), mdx(\"p\", null, \"Let $\\\\vec L \\\\in \\\\R^n$ be given in component form as \"), mdx(\"p\", null, \"$$\\\\vec L = (L_1, L_2, ..., L_n)$$\"), mdx(\"p\", null, \"Then $\\\\lim\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{t \\\\rightarrow t_0} \\\\vec r(t) = \\\\vec L$ in $\\\\R^n$ iff $\\\\forall j \\\\in \", \"{\", \"1, ..., n\", \"}\", \"$, one has $\\\\lim\"), \"{t \\\\rightarrow t_0} r_j(t) = \\\\vec L_j$ in $\\\\R$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We can apply analysis for one-dimension component-wise to proof properties of vector functions\")), mdx(\"h4\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"In general, if $\\\\vec v = (v_1, v_2, ..., v_n) \\\\in \\\\R^n$\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"h2\", {\n    \"id\": \"derivatives\"\n  }, \"Derivatives\"), mdx(\"p\", null, \"Let $t \\\\in I$ be given. Say $\\\\vec r$ is differentiable at $t$ iff $\\\\exists \\\\vec r'(t) \\\\in \\\\R^n$ such that\"), mdx(\"p\", null, \"$$ \\\\lim_{\\\\Delta t \\\\rightarrow 0} \\\\frac{1}{\\\\Delta t}(\\\\vec r (t + \\\\Delta t) - \\\\vec r (t)) = \\\\vec r'(t)$$\"), mdx(\"p\", null, \"Then $\\\\vec r'(t)$ is the (vector-)derivative of $\\\\vec r$ at $t$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$\\\\vec r$ is differentiable at $t$ if all its component functions are differentiable at $t$.\")), mdx(\"h3\", {\n    \"id\": \"differentiation-rules\"\n  }, \"Differentiation Rules\"), mdx(\"p\", null, \"Let $\\\\vec u$ and $\\\\vec v$ be differentiable vector functions of $t$, $\\\\vec C$ a constant vector function, $c$ any scalar, and $f$ any differentiable scalar function.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \\\\vec C = \\\\vec 0$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[c \\\\vec u (t)]\", \"= c \\\\vec u'(t)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[f(t) \\\\vec u (t)]\", \"= f'(t) \\\\vec u(t) + f(t) \\\\vec u'(t)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[\\\\vec u (t) + \\\\vec v(t)]\", \"= \\\\vec u'(t) + \\\\vec v'(t)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[\\\\vec u (t) \\\\cdot \\\\vec v(t)]\", \"= \\\\vec u'(t) \\\\cdot \\\\vec v (t) + \\\\vec u(t) \\\\cdot \\\\vec v'(t)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[\\\\vec u (f(t))]\", \"= f'(t) \\\\vec u'(f(t))$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\frac{d}{dt} \", \"[\\\\vec u (t) \\\\times \\\\vec v(t)]\", \"= \\\\vec u'(t) \\\\times \\\\vec v (t) + \\\\vec u(t) \\\\times \\\\vec v'(t)$\")), mdx(\"h2\", {\n    \"id\": \"integrals\"\n  }, \"Integrals\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"p\", null, \"Rieman definition of integrals transposed to $\\\\R^n$.\"), mdx(\"h2\", {\n    \"id\": \"more-definitions\"\n  }, \"More definitions\"), mdx(\"p\", null, \"$\\\\vec r$ is continuously differentiable (\\\"of class $C^1$\\\") iff $\\\\vec r$ is differentiable and $\\\\vec r' : I \\\\rightarrow \\\\R^n$ is continuous.\"), mdx(\"hr\", null), mdx(\"p\", null, \"The parameterized curve given by $\\\\vec r$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"smooth\"), \" iff $\\\\vec r$ is continuously differentiable and has [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"non-vanishing-derivative\",\n    \"title\": \"Non-Vanishing Derivative\"\n  }, \"non-vanishing-derivative\"), \"]s.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\\"smooth\\\" has a different technical definition in analysis, geometry, etc.\")), mdx(\"hr\", null), mdx(\"p\", null, \"The parameterized curve given by $\\\\vec r : I \\\\rightarrow \\\\R^n$ is piecewise smooth iff $\\\\vec r$ is continuous,\"), mdx(\"p\", null, \"and exists a partition of the interval $I = \", \"[a, b]\", \"$, say \"), mdx(\"p\", null, \"$$a = t\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 < t_1 < ... < t\"), \"{n - 1} < t_n = b$$\"), mdx(\"p\", null, \"such that $\\\\forall j \\\\in {1, ..., n}$, $\\\\vec r$ restricted to $\", \"[t_{j - 1}, t_j]\", \"$ is smooth.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Thus $\\\\vec r$ is allowed to be non-differentiable at the partition points $\\\\vec r(t_1), \\\\vec r(t_2), ..., \\\\vec r(t_n)$ \")), mdx(\"h2\", {\n    \"id\": \"arc-length\"\n  }, \"Arc Length\"), mdx(\"p\", null, \"Let $I = \", \"[a, b]\", \" \\\\subseteq \\\\R'$ be a closed interval.\"), mdx(\"p\", null, \"Let $\\\\vec r : I \\\\rightarrow \\\\R^n$ be a smooth parameterized curve in $\\\\R^n$.\"), mdx(\"p\", null, \"The length of the curve parameterized by $\\\\vec r$ is defined to be the integral \"), mdx(\"p\", null, \"$$\\\\int^b_a \\\\vert \\\\vec r '(t) \\\\vert \\\\, dt$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If $\\\\vec r$ is piecewise smooth, its length is defined to be the sum of the length of its smooth pieces.\")), mdx(\"h3\", {\n    \"id\": \"remark\"\n  }, \"Remark\"), mdx(\"p\", null, \"Why is this definition of length reasonable?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Take a line segment in $\\\\R^n$. Note that integration length agrees with the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Euclidean space length\"), \" of the vector represented by that line segment.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"9798d058-8405-5f74-90ae-b9aa563d16c9","fields":{"slug":"/ma2104/curves","title":"Curves in $\\R^n$"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"multivariable-functions\"\n  }, \"Multivariable Functions\"), mdx(\"p\", null, \"Multivariable Functions\"), mdx(\"p\", null, \"An \\\"$n$-dimensional\\\" vector-valued function of \\\"$m$-variables\\\" is a function of the form $f: R \\\\rightarrow \\\\R^n$ where\\n$R \\\\subseteq \\\\R^m$ is a (open) region.\"), mdx(\"p\", null, \"Take the function to take in a $m$-dimensional vector as input and returns a $n$-dimensional vector.\"), mdx(\"h2\", {\n    \"id\": \"limits\"\n  }, \"Limits\"), mdx(\"p\", null, \"$\\\\epsilon - \\\\delta$ defintion for multivariable functions.\"), mdx(\"p\", null, \"Let $t_o \\\\in I$ and $\\\\vec L \\\\in \\\\R^n$. Say $\\\\vec r$ has limit $\\\\vec L$ as $t \\\\rightarrow t_0$ iff \"), mdx(\"p\", null, \"$$\\\\forall \\\\epsilon \\\\in \\\\R\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{>0}, \\\\exist \\\\delta \\\\in \\\\R\"), \"{>0}$$\"), mdx(\"h3\", {\n    \"id\": \"limit-laws\"\n  }, \"Limit Laws\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"continuity\"\n  }, \"Continuity\"), mdx(\"p\", null, \"A function $f$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"continuous at the point $\\\\bold x_0$\"), \" if \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f$ is defined at $\\\\bold x_0$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\lim_{\\\\bold x \\\\rightarrow \\\\bold x_0} f(\\\\bold x)$ exists\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\lim_{\\\\bold x \\\\rightarrow \\\\bold x_0} f(\\\\bold x) = f(\\\\bold x_0)$.\")), mdx(\"p\", null, \"A function is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"continuous\"), \" if it is continuous at every point in its domain.\"), mdx(\"h3\", {\n    \"id\": \"continuity-of-compositions\"\n  }, \"Continuity of Compositions\"), mdx(\"p\", null, \"Suppose $f: S \\\\rightarrow \\\\R^m, S \\\\subseteq \\\\R^l$\\nand $g: R \\\\rightarrow \\\\R^n, S \\\\subseteq \\\\R^m$\\nand $f(S) \\\\subseteq R$ (so that $g \\\\circ f : S \\\\rightarrow \\\\R^n$ is defined)\"), mdx(\"p\", null, \"For any $\\\\vec q_0 \\\\in S$, if $f$ is continuous at $\\\\vec q_0$\\nand $g$ is continuous at $f(\\\\vec q_0)$\\nthen $g \\\\circ f$ is continuous at $\\\\vec q_0$.\"), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"h2\", {\n    \"id\": \"differentiability\"\n  }, \"Differentiability\"), mdx(\"p\", null, \"There must exist some linear transformation $A$ such that \"), mdx(\"p\", null, \"Say $f$ is differentiable at $\\\\vec p\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 \\\\in R$ iff\\nthere exists a linear transformation $A : \\\\R^m \\\\rightarrow \\\\R^n$\\nsuch that $\\\\forall \\\\epsilon \\\\in \\\\R\"), \"{> 0}, \\\\exist \\\\delta \\\\in \\\\R_{>0}$ such that\"), mdx(\"p\", null, \"$$\\\\vert f(\\\\vec p) - (f(\\\\vec p_0) + A \\\\cdot (\\\\vec p - \\\\vec p_0)) \\\\vert \\\\leq \\\\epsilon \\\\vert \\\\vec p - \\\\vec p_0 \\\\vert$$\"), mdx(\"p\", null, \"The linear transformation $A$ is the uniquely determined (if it exists) and is called the (total) derivative of $f$ at $p_0$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"uses hypothesis that $R$ is open.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Say $f$ is continuously differentiable on $R$ iff $f$ is differentiable on $R$ and $f'$ is differentiable.\")), mdx(\"h2\", {\n    \"id\": \"differentiability-implies-continuity\"\n  }, \"Differentiability Implies Continuity\"), mdx(\"p\", null, \"Suppose $f: R \\\\rightarrow \\\\R^n$ is differentiable at $\\\\vec p_0 \\\\in R$, then\\n$f$ is continuous.\"), mdx(\"h2\", {\n    \"id\": \"directional-derivative\"\n  }, \"Directional Derivative\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"derivative of $f$ at point $p_0$ in the direction of the vector $\\\\vec u$\"), \".\"), mdx(\"p\", null, \"Let $R \\\\subseteq \\\\R^m$ be an open region.\"), mdx(\"p\", null, \"Let $f : R \\\\rightarrow \\\\R^n$ be a function.\"), mdx(\"p\", null, \"Let $\\\\vec u \\\\in \\\\R^m$ be any vector(\\\"direction\\\").\"), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"derivative of $f$ in the direction $\\\\vec u$ at $\\\\vec p_0 \\\\in R$\"), \" is the limit\\n$(D_{\\\\vec u} f)(\\\\vec p_0) \\\\in \\\\R^n$ given by\"), mdx(\"p\", null, \"$$(D\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{\\\\vec u} f)(\\\\vec p_0) := \\\\lim\"), \"{s \\\\rightarrow 0} \\\\frac{f( \\\\vec p_0 + s \\\\vec u ) - f(\\\\vec p_0)}{s}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Consider a (small) open interval $I = (-c, c) \\\\subseteq \\\\R$ such that $\\\\forall s \\\\in I$, one has $\\\\vec p_0 + s \\\\cdot \\\\vec u \\\\in R$.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"to get function $f\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{\\\\vec u, \\\\vec p_0} : I \\\\rightarrow \\\\R^n, f\"), \"{\\\\vec u, \\\\vec p_0} := f(\\\\vec p_0 + s \\\\cdot \\\\vec u)$\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Then $(D\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{\\\\vec u} f)(\\\\vec p_0) = (\\\\frac{d}{ds} f\"), \"{\\\\vec u, \\\\vec p_0})(0)$.\")), mdx(\"h2\", {\n    \"id\": \"partial-derivatives\"\n  }, \"Partial Derivatives\"), mdx(\"p\", null, \"The partial derivatives are the directional derivatives of $f$ at $p_0$ in the basis vector directions.\"), mdx(\"p\", null, \"In general:\"), mdx(\"p\", null, \"Let $R \\\\subseteq \\\\R^m$ be an open region.\"), mdx(\"p\", null, \"Let $f : R \\\\rightarrow \\\\R^n$ be a function.\"), mdx(\"p\", null, \"Let $\\\\vec e_1, ... \\\\vec e_m \\\\in \\\\R^m$ be the standard basis vectors.\"), mdx(\"p\", null, \"For $j \\\\in \", \"{\", \" 1, ..., m \", \"}\", \"$, the $j^{th}$ partial derivative of $f$ at $p\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 \\\\in R$ is the derivative of $f$ in the direction $\\\\vec e_j$ at $\\\\vec p_0 \\\\in R$\\ndenoted as $\\\\frac{\\\\partial f}{\\\\partial x_j}(\\\\vec p_0)$ or $f\"), \"{x_j}(\\\\vec p_0)$.\"), mdx(\"p\", null, \"Thus \"), mdx(\"p\", null, \"$$ \\\\frac{\\\\partial f}{\\\\partial x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"j}(\\\\vec p_0) = f\"), \"{x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"j}(\\\\vec p_0) = (D\"), \"{\\\\vec e_j}f)(\\\\vec p_0) $$\"), mdx(\"p\", null, \"is the limit\"), mdx(\"p\", null, \"$$\\\\lim_{s \\\\rightarrow 0} \\\\frac{f( \\\\vec p_0 + s \\\\vec e_j ) - f(\\\\vec p_0)}{s}$$\"), mdx(\"p\", null, \"in $\\\\R^n$ (if it exists).\"), mdx(\"h2\", {\n    \"id\": \"relationship-between-derivatives\"\n  }, \"Relationship between Derivatives\"), mdx(\"p\", null, \"Suppose $f: R \\\\rightarrow \\\\R^n$ is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"differentiable at $\\\\vec p_0 \\\\in R$\"), \" (so the total derivative exists and is a linear transformation $\\\\R^m \\\\rightarrow \\\\R^n$)\"), mdx(\"p\", null, \"Then for any $\\\\vec u \\\\in \\\\R^n$, the $\\\\vec u$-directional derivative $(D_{\\\\vec u} f)(\\\\vec p_0)$ of $f$ at $\\\\vec p_0$ exists and is equal to \"), mdx(\"p\", null, \"$$(D_{\\\\vec u} f)(\\\\vec p_0) = (Df)(\\\\vec p_0) \\\\times \\\\vec u \\\\in \\\\R^n$$\"), mdx(\"p\", null, \"In particular, for each $j \\\\in \", \"{\", \"1, ..., m\", \"}\", \"$,\\nthe $j^{th}$ partial derivative $\\\\frac{\\\\partial f}{\\\\partial x_j} (\\\\vec p_0)$ of $f$ at $\\\\vec p_0$ exists and is equal to \"), mdx(\"p\", null, \"$$\\\\frac{\\\\partial f}{\\\\partial x_j}(\\\\vec p_0) = (Df)(\\\\vec p_0) \\\\times \\\\vec e_j \\\\in \\\\R^n$$\"), mdx(\"p\", null, \"which is the $j^{th}$ column of the total derivative.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"It can happen that all partial derivatives exist but the function is not continuous at $\\\\vec p_0$, hence not differentiable.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"80ffffd2-a40b-5007-b8b3-9d5214451d93","fields":{"slug":"/ma2104/multivariable-functions","title":"Multivariable Functions"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"higher-order-derivatives\"\n  }, \"Higher Order Derivatives\"), mdx(\"h2\", {\n    \"id\": \"twice-continuously-differentiable\"\n  }, \"Twice Continuously Differentiable\"), mdx(\"p\", null, \"Say $f$ is twice continuously differentiable iff $f$ is differentiable on $R$\\nand $f'$ is differentiable as a function $R \\\\rightarrow \\\\mathbb{M}_{n \\\\times m}$.\"), mdx(\"p\", null, \"In general, say $f$ is of class $C^0$ iff $f$ is continuous.\"), mdx(\"p\", null, \"For $r \\\\geq 1$, say $f$ is of class $C^r$ iff $f$ is differentiable on $R$ and $f'$ is of class $C^{r - 1}$.\"), mdx(\"h2\", {\n    \"id\": \"characterization-of-continuous-differentiability\"\n  }, \"Characterization of Continuous Differentiability\"), mdx(\"p\", null, \"A function $f: R \\\\rightarrow \\\\R^n$, is of class $C^r$ iff\\nfor each $i \\\\in \", \"{\", \"1, ..., n\", \"}\", \"$ , for each $j \\\\in \", \"{\", \"1, ..., m\", \"}\", \"$,\\nfor all $\\\\vec p_0 \\\\in R$,\\nthe $j^{th}$ partial derivative $\\\\frac{\\\\partial f_i}{\\\\partial x_j}(\\\\vec p_0)$ of $f_i$ at $\\\\vec p_0$ exists,\\nand the function $\\\\frac{\\\\partial f_i}{\\\\partial x_j} : R \\\\rightarrow \\\\R$ is of class $C^{r-1}$.\"), mdx(\"hr\", null), mdx(\"h3\", {\n    \"id\": \"notation\"\n  }, \"Notation\"), mdx(\"p\", null, \"$$ \\\\frac{\\\\partial^r f\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i}{\\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"d} \\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{d-1}}...\\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}} := \\\\frac{\\\\partial}{\\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"d}} \\\\bigg (\\\\frac{\\\\partial^{r-1}f_i}{\\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{d - 1}}... \\\\partial x\"), \"{j\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}} \\\\bigg ) := ({f_i})\"), \"{x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{j_1}...x\"), \"{j_d}}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note the reverse in pattern\")), mdx(\"hr\", null), mdx(\"p\", null, \"$f : R \\\\rightarrow \\\\R^n$ is of class $C^r$ iff\\nfor each $i \\\\in \", \"{\", \"1, ..., n\", \"}\", \"$ , for each $j \\\\in \", \"{\", \"1, ..., m\", \"}\", \"$,\"), mdx(\"p\", null, \"the function $(f\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i)\"), \"{x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{j_1}...x\"), \"{j_r}} : R \\\\rightarrow \\\\R$ exists and is continuous.\"), mdx(\"h2\", {\n    \"id\": \"equality-of-mixed-partial-derivatives\"\n  }, \"Equality of Mixed Partial Derivatives\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The indices can be in any order, the partial derivative will be the same.\")), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"Requires [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../ma3110/mean-value-theorem\",\n    \"title\": \"Mean Value Theorem\"\n  }, \"mean-value-theorem\"), \"], which is not in the scope of this module.\"), mdx(\"h2\", {\n    \"id\": \"taylors-theorem-for-multivariables\"\n  }, \"Taylor's Theorem for Multivariables\"), mdx(\"hr\", null), mdx(\"p\", null, \"Recall [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../ma3110/taylors-theorem\",\n    \"title\": \"Taylor's Theorem\"\n  }, \"taylors-theorem\"), \"]\"), mdx(\"h3\", {\n    \"id\": \"remainder-estimation-theorem\"\n  }, \"Remainder Estimation Theorem\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"remainder-estimation-theorem\",\n    \"title\": \"Remainder Estimation Theorem\"\n  }, \"remainder-estimation-theorem\"), \"]\"), mdx(\"hr\", null), mdx(\"p\", null, \"Let $f: R \\\\rightarrow \\\\R$ be a (scalar-valued) function on $R$ open in $\\\\R^m$ of class $C^{r + 1}$ ($r \\\\geq 1$).\"), mdx(\"p\", null, \"Let $\\\\vec p\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 \\\\in R$, and suppose $\\\\delta \\\\in \\\\R\"), \"{> 0}$, such that $B_{\\\\R^m}(\\\\vec p_0, \\\\delta) \\\\subseteq R$\"), mdx(\"p\", null, \"Then $\\\\forall \\\\vec \\\\xi \\\\in \\\\R^m$ with $\\\\vert \\\\vec \\\\xi \\\\vert < \\\\delta$, one has\"), mdx(\"p\", null, \"$$ f(\\\\vec p\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0 + \\\\vec \\\\xi) = \\\\sum^e\"), \"{d = 0} \\\\sum_{\\\\alpha \\\\in \\\\N^m, \\\\vert \\\\alpha \\\\vert = d} \\\\frac{1}{\\\\alpha !} \\\\frac{\\\\partial^d f}{\\\\partial x_1^{\\\\alpha_1} ...\\\\partial x_m^{\\\\alpha_m}} (\\\\vec p_0) \\\\cdot \\\\xi_1^{\\\\alpha_1} ... \\\\xi_m^{\\\\alpha_m} + R(\\\\vec \\\\xi)$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"sum over degrees $d$ up to $r$\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"sum over all $m$-tuples of exponents of degree $d$\")), mdx(\"p\", null, \"where $\\\\alpha = (\\\\alpha\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1, ..., \\\\alpha_m) \\\\in \\\\Z^m\"), \"{\\\\geq 0}$\"), mdx(\"p\", null, \"$\\\\vert \\\\alpha \\\\vert = \\\\alpha_1 + ... + \\\\alpha_m$\"), mdx(\"p\", null, \"$\\\\alpha ! = \\\\alpha_1 ! + ... + \\\\alpha_m !$\"), mdx(\"p\", null, \"and $\\\\exist c \\\\in (0, 1)$ such that\"), mdx(\"p\", null, \"$$\\nR(\\\\vec \\\\xi) = \\\\sum_{\\\\alpha \\\\in \\\\N^m, \\\\vert \\\\alpha \\\\vert = d} \\\\frac{1}{\\\\alpha !} \\\\frac{\\\\partial^{r + 1} f}{\\\\partial x_1^{\\\\alpha_1} ...\\\\partial x_m^{\\\\alpha_m}} (\\\\vec p_0 + c \\\\vec \\\\xi) \\\\cdot \\\\xi_1^{\\\\alpha_1} ... \\\\xi_m^{\\\\alpha_m}\\n$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"d27521e7-827c-52ad-bbee-9517eb53e40c","fields":{"slug":"/ma2104/higher-order-derivatives","title":"Higher Order Derivatives"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"multivariable-integration\"\n  }, \"Multivariable Integration\"), mdx(\"h2\", {\n    \"id\": \"integral-of-a-function\"\n  }, \"Integral of a Function\"), mdx(\"p\", null, \"For any compact rectangle $X$ in Euclidean space, we will \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"specify a vector space $R(X)$ of $\\\\R$-valued functions on $X$.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"define a linear map $R(X) \\\\rightarrow \\\\R$, $f \\\\rightarrow \\\\int_X f(x) \\\\; dx$.\")), mdx(\"p\", null, \"A compact rectangle in $\\\\R^m$ is a subset $X \\\\subseteq \\\\R^m$ of the form $X = X_1 \\\\times X_2 \\\\times ... X_m$\\nwhere each $X_i$ is a closed and bounded interval in $\\\\R$.\"), mdx(\"p\", null, \"The volume of $X$ is $\\\\vert X \\\\vert := \\\\prod^m\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{i = 1} (b_i - a_i) \\\\in \\\\R\"), \"{\\\\geq 0}$\"), mdx(\"p\", null, \"A partition of $X\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i$ is a collection of closed sub-intervals of $X_i$ of the form $P_i = \", \"{\", \"[x_0, x_1]\", \", ..., [x\"), \"{k - 1}, x_k] \", \"}\", \"$\"), mdx(\"p\", null, \"A partition of $X$ is a collection of subsets of $X$ of the form $P_i = \", \"{\", \"R_1 \\\\times ... \\\\times R_m \\\\subseteq X : R_1 \\\\in P_1, ..\", \"}\", \"$\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"norm\"), \" of $P$ is $\\\\Vert P \\\\Vert = \\\\max\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i (\\\\max\"), \"{R_i \\\\in P_i} \\\\vert R_i \\\\vert)$\\ni.e. the maximum side length among the pieces in $P$.\"), mdx(\"h2\", {\n    \"id\": \"riemann-sum\"\n  }, \"Riemann Sum\"), mdx(\"p\", null, \"Let $X \\\\subseteq \\\\R^m$ be a compact rectangle,\\nlet $f: X \\\\rightarrow \\\\R^n$ be a vector valued function on $X$.\"), mdx(\"p\", null, \"For any partition $P$ of $X$,\\nfor any function $t: P \\\\rightarrow X$ such that $\\\\forall R \\\\in P$, $t(R) \\\\in R$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"choose a point in that partition\")), mdx(\"p\", null, \"the Riemann Sum of $f$  with respect to $P$ and $t$ is\"), mdx(\"p\", null, \"$$S(f; P, t) := \\\\sum_{R \\\\in P} f(t(R)) \\\\cdot \\\\vert R \\\\vert \\\\; \\\\in \\\\R^n$$\"), mdx(\"h2\", {\n    \"id\": \"riemann-integrable\"\n  }, \"Riemann Integrable\"), mdx(\"p\", null, \"We say that the function $f: X \\\\rightarrow \\\\R^n$ is Riemann integrable iff\\nthe limit $\\\\lim_{P, t, \\\\Vert P \\\\Vert \\\\rightarrow 0} S(f; P, t)$ exists in $\\\\R^n$.\"), mdx(\"p\", null, \"$\\\\exist L \\\\in \\\\R^n$ such that $\\\\forall \\\\epsilon \\\\in \\\\R_{\\\\geq 0}$, $\\\\exist \\\\delta > 0$ such that \"), mdx(\"p\", null, \"$\\\\forall$ partition $P$ of $X$ with $\\\\Vert P \\\\Vert < \\\\delta$\"), mdx(\"p\", null, \"$\\\\forall$ function $t: P \\\\rightarrow X$ with $\\\\forall R \\\\in P$, $t(R) \\\\in R$,\"), mdx(\"p\", null, \"one has $\\\\vert S(f; P, t)- L \\\\vert < \\\\epsilon$\"), mdx(\"p\", null, \"When this holds, the vector $L \\\\in \\\\R^n$ is uniquely determined by $f$ and is denoted $\\\\int_X f(x) \\\\; dx$ called the Riemann integral of $f$ over $X$.\"), mdx(\"h2\", {\n    \"id\": \"properties-of-riemann-integrals\"\n  }, \"Properties of Riemann Integrals\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Constant multiple\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Linear over sum and difference\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Domination ($\\\\int$ is order-preserving)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Additivity: Sum of non overlapping regions\")), mdx(\"h2\", {\n    \"id\": \"theorem\"\n  }, \"Theorem\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"non trivial!\")), mdx(\"p\", null, \"Every continuous function on $X$ (compact rectangle) is Riemann integrable.\"), mdx(\"p\", null, \"More generally,\"), mdx(\"p\", null, \"A function $f:X \\\\rightarrow \\\\R$ is Riemann integrable iff $f$ is bounded and $Dis(f) := \", \"{\", \" x \\\\in X : \\\\text{f is not continuous on X}\", \"}\", \"$\\nis of measure $0$ in $\\\\R^m$.\"), mdx(\"p\", null, \"This means $\\\\forall \\\\epsilon \\\\in \\\\R_{> 0}$, $\\\\exist$ rectangles $R_1, R_2, ..., R_n \\\\in \\\\R^m$ such that $Dis(f) \\\\subseteq R_1 \\\\cup, ..., \\\\cup R_n$ and $\\\\vert R_1 \\\\vert + ... < \\\\epsilon$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The discontinuous points are small enough that they don't affect volume.\")), mdx(\"h2\", {\n    \"id\": \"fubini-theorem-for-riemann-integral\"\n  }, \"Fubini Theorem for Riemann Integral\"), mdx(\"p\", null, \"Let $X \\\\subseteq \\\\R^m$ and $Y \\\\in \\\\R^l$ be compact rectangles\"), mdx(\"p\", null, \"Let $f: X \\\\times Y \\\\rightarrow \\\\R$ be a Riemann integrable function.\"), mdx(\"p\", null, \"If the function $F: X \\\\rightarrow \\\\R$, $F(x) = \\\\int_Y f(x, y) \\\\; dy$ is defined.\"), mdx(\"p\", null, \"then $F$ is Riemann integrable over $X$, and \"), mdx(\"p\", null, \"$$\\\\int_{X \\\\times Y} f(x,y) \\\\; d(x, y) = \\\\int_X F(x) \\\\; dy = \\\\int_X \\\\int_Y f(x, y) \\\\; dy \\\\; dx$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This allows us to reduce integration in $m$ variables to iterated integration in 1 variable\")), mdx(\"h3\", {\n    \"id\": \"consequence\"\n  }, \"Consequence\"), mdx(\"p\", null, \"If $f: X \\\\times Y \\\\rightarrow \\\\R$ is continuous on $X \\\\times Y$.\\nThen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Y \\\\int_X f(x, y) \\\\; dx \\\\; dy = \\\\int\"), \"{X \\\\times Y} f(x,y) \\\\; d(x, y) = \\\\int_X \\\\int_Y f(x, y) \\\\; dy \\\\; dx$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2caba198-92f2-5639-bafe-4a37c1a4097e","fields":{"slug":"/ma2104/multivariable-integration","title":"Multivariable Integration"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"integration-by-substitution\"\n  }, \"Integration by Substitution\"), mdx(\"p\", null, \"Suppose that the functions $\\\\phi : \", \"[a, b]\", \" \\\\rightarrow \\\\R$ is such that $\\\\phi'$ exists and is integrable on $\", \"[a, b]\", \"$.\"), mdx(\"p\", null, \"If $f:I \\\\rightarrow \\\\R$ is continuous on an interval $I$ containing $\\\\phi(\", \"[a, b]\", \")$, then\"), mdx(\"p\", null, \"$$\\\\int^b\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"a f(\\\\phi(t))\\\\phi'(t) dt = \\\\int^{\\\\phi(b)}\"), \"{\\\\phi(a)} f(x) dx$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"6d653cfc-edb2-5219-865f-5b78ba45a8b3","fields":{"slug":"/ma3110/integration-by-substitution","title":"Integration by Substitution"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"line-integrals\"\n  }, \"Line Integrals\"), mdx(\"h2\", {\n    \"id\": \"line-integral-of-scalar-valued-functions\"\n  }, \"Line Integral of (scalar-valued) functions\"), mdx(\"p\", null, \"A parametrized curve in $\\\\R^n$ is a function\\n$\\\\vec r : I \\\\rightarrow \\\\R^n$ from an interval $I \\\\subseteq \\\\R$ to Euclidean n-space $\\\\R^n$.\"), mdx(\"p\", null, \"The parametrized curve given by $\\\\vec r$ is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"smooth\"), \" iff\\n$\\\\vec r$ is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"continuously differentiable\"), \" and has \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"non-vanishing derivative\"), \". $(\\\\vec r (t) \\\\neq 0) \\\\forall t in I$.\"), mdx(\"p\", null, \"Geometrically, we think of the image set $C := \\\\vec r (I) \\\\subseteq \\\\R^n$ as a smooth \\\"curve\\\" in $\\\\R^n$ and the function $\\\\vec r : I \\\\rightarrow C$ as a (auxiliary) parametrization.\"), mdx(\"h3\", {\n    \"id\": \"smooth-curve\"\n  }, \"Smooth curve\"), mdx(\"p\", null, \"A smooth curve in $\\\\R^n$ is a subset $C \\\\subseteq \\\\R^n$ such that there exists a bijective smooth parametrization $\\\\vec r : I \\\\rightarrow C$, where $I \\\\subseteq \\\\R$ is an interval\"), mdx(\"hr\", null), mdx(\"p\", null, \"Suppose $\\\\vec r : I \\\\rightarrow C, \\\\vec s : J \\\\rightarrow C$ are bijective smooth parametrizations.\"), mdx(\"p\", null, \"Then there exists a bijective \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"continuously differentiable\"), \" map $\\\\Phi : I \\\\rightarrow J$ such that $\\\\vec r = \\\\vec s \\\\circ \\\\Phi$.\"), mdx(\"hr\", null), mdx(\"p\", null, \"Let $C$ be a smooth curve in $\\\\R^n$.\\nLet $f : C \\\\rightarrow \\\\R$ be a scalar valued function on $C$.\"), mdx(\"p\", null, \"The line integral of $f$ over $C$ is $\\\\int_C f \\\\; ds \\\\in \\\\R$ defined as follows\"), mdx(\"p\", null, \"Choose any bijective smooth parametrization $\\\\vec r : I \\\\rightarrow C$.\\nSet\"), mdx(\"p\", null, \"$$\\\\int_C f \\\\; ds := \\\\int_I f(\\\\vec r(t)) \\\\vert \\\\vec r'(t) \\\\vert \\\\; dt$$\"), mdx(\"p\", null, \"This is well-defined, independent of choice of parameter $\\\\vec r$\"), mdx(\"h4\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"If $\\\\vec s : J \\\\rightarrow C$ is another, then by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fact^\"), \", there exists $\\\\Phi : I \\\\rightarrow J$ such that $\\\\vec r = \\\\vec s \\\\circ \\\\Phi$\"), mdx(\"p\", null, \"Thus by change of variable $u = \\\\Phi(t)$.\"), mdx(\"p\", null, \"$$ \\\\int_I f(\\\\vec r (t)) \\\\vert \\\\vec r'(t) \\\\vert \\\\; dt\\n= \\\\int_I f(\\\\vec s (\\\\Phi(t))) \\\\cdot \\\\vert \\\\vec s'(\\\\Phi(t)) \\\\vert \\\\vert \\\\Phi'(t) \\\\vert \\\\; dt\\n= \\\\int_J f(\\\\vec s(u)) \\\\cdot \\\\vert \\\\vec s'(u) \\\\vert \\\\; du $$\"), mdx(\"h2\", {\n    \"id\": \"additivity\"\n  }, \"Additivity\"), mdx(\"p\", null, \"Line integrals have the useful property that if a piecewise smooth curve $C$ is made by joining a finite number of smooth curves $C_1, C_2, .., C_n$ end to end,\\nthen the integral of a function over $C$ is the sum of the integrals over the curves that make it up.\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"C f \\\\; ds = \\\\int\"), \"{C\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1} f \\\\; ds + \\\\int\"), \"{C\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2} f \\\\; ds + ... + \\\\int\"), \"{C_n} f \\\\; ds $$\"), mdx(\"h1\", {\n    \"id\": \"vector-fields\"\n  }, \"Vector Fields\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"gradient of a function\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"line integral of a vector field\")), mdx(\"p\", null, \"Let $X$ be any subset of $\\\\R^n$.\\nA \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"vector field\"), \" on $X$ is a vector-valued function $\\\\vec F : X \\\\rightarrow \\\\R^n$ from $X$ to $\\\\R^n$.\\nThe vector field $\\\\vec F : X \\\\rightarrow \\\\R^n$ is continuous / smooth iff $\\\\vec F$ (as a vector-valued function) is continuous / smooth\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Same as vector-valued function, just that output dimension is the same as input\")), mdx(\"h2\", {\n    \"id\": \"types\"\n  }, \"Types\"), mdx(\"h3\", {\n    \"id\": \"constant-vector-field\"\n  }, \"Constant Vector Field\"), mdx(\"p\", null, \"Fix any vector $\\\\vec v_0 \\\\in \\\\R^n$\"), mdx(\"p\", null, \"Set $\\\\vec F : X \\\\rightarrow \\\\R^n$ to be $\\\\vec F (\\\\vec p) := \\\\vec v_0$\"), mdx(\"h3\", {\n    \"id\": \"position-vector-field\"\n  }, \"\\\"Position\\\" Vector Field\"), mdx(\"p\", null, \"$\\\\vec F : X \\\\rightarrow \\\\R^n$ to be $\\\\vec F (\\\\vec p) := \\\\vec p$.\"), mdx(\"h2\", {\n    \"id\": \"gradient-field\"\n  }, \"Gradient Field\"), mdx(\"p\", null, \"Let $U \\\\subseteq \\\\R^n$ be an open set,\\nand $f: U \\\\rightarrow \\\\R$ be a scalar-valued differentiable function\"), mdx(\"p\", null, \"The gradient $\\\\nabla f$ of $f$ is the total derivative map of $f' : U \\\\rightarrow \\\\mathbb{M}_{1 \\\\times n}(\\\\R) = \\\\R^n$ (regarded as a vector field on $U$)\"), mdx(\"p\", null, \"Explicitly, $\\\\nabla f: U \\\\rightarrow \\\\R^n$ is given by\\nfor each $\\\\vec p \\\\in U$, partial differentiation on each component.\"), mdx(\"p\", null, \"Thus $\\\\nabla f$ is a vector field on $U$, \"), mdx(\"p\", null, \"is continuous vector field iff $f$ is continuously differentiable.\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"gradient vector field\"), \" on $U$ is a vector field $\\\\vec F : U \\\\rightarrow \\\\R^n$\\nsuch that there exists a scalar-valued differentiable function $f: U \\\\rightarrow \\\\R$ such that $\\\\vec F = \\\\nabla f$.\"), mdx(\"p\", null, \"When this is so, the function $f$ is called a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"potential function\"), \" of (the vector field) $\\\\vec F$.\"), mdx(\"h3\", {\n    \"id\": \"algebra-rules-for-gradients\"\n  }, \"Algebra Rules for Gradients\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sum Rule\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Difference Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Constant Multiple Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Product Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Quotient Rule\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Similar to single variate differentiation\")), mdx(\"h2\", {\n    \"id\": \"line-integral-of-vector-field-over-a-curve\"\n  }, \"Line Integral of Vector Field over a Curve\"), mdx(\"p\", null, \"Let $C$ be a smooth curve in $\\\\R^n$ given with a bijective smooth parameterization $\\\\vec r : I \\\\rightarrow C$\"), mdx(\"p\", null, \"Let $\\\\vec F : C \\\\rightarrow \\\\R$ be a continuous vector field on $C$.\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"line integral\"), \" of $\\\\vec F$ over $C$ with respect to $\\\\vec r$ is defined as\"), mdx(\"p\", null, \"$$\\\\int_C \\\\vec F \\\\cdot d \\\\vec r := \\\\int_I \\\\vec F(\\\\vec r (t)) \\\\cdot \\\\vec r '(t) \\\\; dt$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This depends on the chosen parameter $\\\\vec r$ of $C$ but only up to orientation:\")), mdx(\"p\", null, \"If $\\\\vec s : J \\\\rightarrow C$ is another parameterization\\nthen there exists $\\\\Phi : I \\\\rightarrow J$ that is a contin differentiable bijection\\nsuch that $\\\\vec r = \\\\vec s \\\\circ \\\\Phi$.\"), mdx(\"p\", null, \"If $\\\\Phi' : I \\\\rightarrow \\\\R$ always takes $>0$ values\\nthen $\\\\vec r$ and $\\\\vec s$ are said to be parameterizing $C$ in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"same orientation\"), \".\"), mdx(\"p\", null, \"When this is so,\"), mdx(\"p\", null, \"$$\\\\int_C \\\\vec F \\\\cdot d \\\\vec r = \\\\int_I \\\\vec F(\\\\vec r (t)) \\\\cdot \\\\vec r'(t) \\\\; dt$$\\n$$= \\\\int_I \\\\vec F(\\\\vec s(\\\\Phi(t))) \\\\cdot \\\\vec s'(\\\\Phi(t)) \\\\Phi'(t) \\\\; dt$$\\n$$= \\\\int_I \\\\vec F(\\\\vec s(u)) \\\\cdot \\\\vec s'(u) \\\\; ds$$\\n$$= \\\\int_C \\\\vec F \\\\cdot \\\\; ds$$\"), mdx(\"p\", null, \"If the orientation is negative, then we get exactly the negative of the above.\"), mdx(\"h1\", {\n    \"id\": \"integral-theorems\"\n  }, \"Integral Theorems\"), mdx(\"h2\", {\n    \"id\": \"fundamental-theorem-of-line-integrals\"\n  }, \"Fundamental Theorem of Line Integrals\"), mdx(\"p\", null, \"Let $C$ be a smooth curve in $\\\\R^n$, say from $A$ to $B$ given with a bijective smooth parameterization\\n$\\\\vec r : I \\\\rightarrow C$.\\nLet $D \\\\subseteq \\\\R^n$ be an open set with $C \\\\subseteq D$ and\\nlet $f: D \\\\rightarrow \\\\R$ be a continuously differentiable (scalar-valued) function.\\nThen\"), mdx(\"p\", null, \"$$ \\\\int_C \\\\nabla f \\\\cdot d \\\\vec r = f(B) - f(A)$$\"), mdx(\"p\", null, \"Note that this works for a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"piecewise smooth function\"), \" as well as the summation is telescopic.\"), mdx(\"h2\", {\n    \"id\": \"remarks-and-questions\"\n  }, \"Remarks and Questions\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Suppose we have to compute some line integral\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How do we know whether $\\\\vec F$ is a gradient vector field?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When we do know that $\\\\vec F$ is a gradient vector field, how do we find $f$ such that $\\\\vec F = \\\\nabla f$?\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If $\\\\vec F$ is a gradient vector field on an open set $D$, then for any smooth curve $C$ in $D$, $\\\\int_C F \\\\cdot d \\\\vec r$ depends only on the end points.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Any other smooth curve $C'$ will give the same answer.\")), mdx(\"h2\", {\n    \"id\": \"conservative-fields\"\n  }, \"Conservative Fields\"), mdx(\"p\", null, \"Let $\\\\vec F$ be a vector field defined on an open region $D$ in space,\\nand suppose that for any two points $A$ and $B$ in $D$ the line integral $\\\\int_C \\\\vec F \\\\cdot d \\\\vec r$ along a path $C$ from $A$ to $B$ in $D$ is the same over all paths from $A$ to $B$.\"), mdx(\"p\", null, \"Then the integral $\\\\int_C \\\\vec F \\\\cdot d \\\\vec r$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"path independent\"), \" in $D$ and the field $\\\\vec F$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"conservative\"), \" on $D$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If $\\\\vec F$ is a gradient vector field, then it is conservative\")), mdx(\"h2\", {\n    \"id\": \"connected-sets\"\n  }, \"Connected Sets\"), mdx(\"p\", null, \"A subset $X \\\\subseteq \\\\R^n$ is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"connected\"), \" iff for any open subsets $U, V$ of $\\\\R^n$ such that $U \\\\cap V \\\\cap X = \\\\varnothing$,\\none has $U \\\\cap X = \\\\phi$ or, $V \\\\cap X = \\\\varnothing$.\"), mdx(\"h3\", {\n    \"id\": \"proposition\"\n  }, \"Proposition\"), mdx(\"p\", null, \"Let $D \\\\subseteq \\\\R^n$ be an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"open\"), \" set.\"), mdx(\"p\", null, \"Then $D$ is connected iff $D$ is path connected ($D$ can be expressed as a piecewise smooth curve)\"), mdx(\"h2\", {\n    \"id\": \"loop-property-of-conservative-fields\"\n  }, \"Loop Property of Conservative Fields\"), mdx(\"p\", null, \"Let $D \\\\subseteq \\\\R^n$ be a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"connected\"), \" open set, $\\\\vec F : D \\\\rightarrow \\\\R^n$ be a continuous vector field on $D$.\"), mdx(\"p\", null, \"Then $\\\\vec F$ is conservative iff for any closed curve $C \\\\in D$,\\none has\"), mdx(\"p\", null, \"$$\\\\oint_c \\\\vec F \\\\cdot d \\\\vec r = 0$$\"), mdx(\"h2\", {\n    \"id\": \"criterion-for-gradient-vector-field\"\n  }, \"Criterion for Gradient Vector Field\"), mdx(\"p\", null, \"Component Test for Conservative Fields\"), mdx(\"p\", null, \"Let $D \\\\subseteq \\\\R^n$ be an open set,\\n$\\\\vec F : D \\\\rightarrow \\\\R^n$ be a continuously differentiable vector field on $D$.\"), mdx(\"p\", null, \"Write $\\\\vec F = (F_1, F_2, ..., F_n)$ with each $F_j : D \\\\rightarrow \\\\R$ a scalar valued function on $D$.\"), mdx(\"p\", null, \"If $\\\\vec F$ is a gradient vector field,\\nthen $\\\\forall i, j \\\\in \", \"{\", \"1, ..., n\", \"}\", \"$, one has\"), mdx(\"p\", null, \"$$\\\\frac{\\\\partial F_i}{\\\\partial x_j} = \\\\frac{\\\\partial F_j}{\\\\partial x_i}$$ \"), mdx(\"p\", null, \"on $D$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"will see that the converse holds whenever $D$ is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"connected\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"simply connected\"), \".\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"4ce7502b-53b0-5e11-9c79-95afa3750113","fields":{"slug":"/ma2104/line-integrals","title":"Line Integrals"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"surface-integrals\"\n  }, \"Surface Integrals\"), mdx(\"h2\", {\n    \"id\": \"surface-integral-of-scalar-valued-functions\"\n  }, \"Surface Integral of (scalar-valued) Functions\"), mdx(\"h3\", {\n    \"id\": \"parametrized-surface\"\n  }, \"Parametrized Surface\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parametrized surface\"), \" in $\\\\R^n$ is a function\\n$\\\\vec r : R \\\\rightarrow \\\\R^n$ from a region $R \\\\in \\\\R^2$ to Euclidean n-space $\\\\R^n$.\"), mdx(\"p\", null, \"The parametrized surface given by $\\\\vec r$ is \\\"smooth\\\" iff $\\\\vec r$ is continuously differentiable (partial derivatives components exists and are continuous)\"), mdx(\"h2\", {\n    \"id\": \"special-case-of-r3\"\n  }, \"Special case of $\\\\R^3$\"), mdx(\"p\", null, \"Let $S$ be a smooth surface in $\\\\R^3$.\"), mdx(\"p\", null, \"Let $G: S \\\\rightarrow \\\\R$ be a (scalar-valued) function on $S$.\"), mdx(\"p\", null, \"The surface integral of $G$ over $S$ is $\\\\int_S G \\\\; d\\\\sigma$ is defined as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Choose any \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"bijective smooth\"), \" parametrization $\\\\vec r : R \\\\rightarrow S$.\")), mdx(\"p\", null, \"$$\\\\int_S G \\\\; d \\\\sigma := \\\\int_R G (\\\\vec r(u, v)) \\\\vert \\\\vec r_u (u, v) \\\\times \\\\vec r_v (u, v) \\\\vert \\\\; d(u, v)$$\"), mdx(\"p\", null, \"(if the RHS exists)\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This is well-defined, independent of choice of parameter $\\\\vec r$\")), mdx(\"h3\", {\n    \"id\": \"additivity\"\n  }, \"Additivity\"), mdx(\"p\", null, \"If a piecewise smooth surface $S$ is obtained by joining a finite number of smooth surfaces $S_1, S_2, ..., S_n$ along boundary curves which are themselves piecewise smooth curves,\\nthen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"S f \\\\; d \\\\sigma = \\\\int\"), \"{S\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1} f \\\\; d \\\\sigma + ... + \\\\int\"), \"{S_n} f \\\\; d \\\\sigma$$\"), mdx(\"h2\", {\n    \"id\": \"surface-integral-of-a-vector-field\"\n  }, \"Surface Integral of a Vector Field\"), mdx(\"p\", null, \"$$\\\\int_S \\\\vec F \\\\cdot \\\\vec n \\\\; d \\\\sigma := \\\\int_R \\\\vec F(\\\\vec r (u, v)) \\\\cdot \\\\vec r_u (u, v) \\\\times \\\\vec r_v (u, v) \\\\; d(u, v)$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Make use of triple product, which gives us a scalar valued function that we can easily integrate iteratively over region $R$.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This depends on the chosen parameter $\\\\vec r$ of $S$ but only up to orientation.\")), mdx(\"p\", null, \"If $\\\\vec \\\\rho : \\\\Omega \\\\rightarrow S$ is another parameterization, then there exists some composed function $\\\\Phi$ that is continuously differentiable and invertible.\"), mdx(\"p\", null, \"If $J_\\\\Phi = det(\\\\Phi') : R \\\\rightarrow \\\\R$ always takes $>0$ values then $\\\\vec r$ and $\\\\vec p$ are said to be parametrizing $S$ in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"same orientation\"), \".\"), mdx(\"h3\", {\n    \"id\": \"the-normal-vector\"\n  }, \"The Normal Vector\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Comparable to the case of curves $\\\\int_C \\\\vec F \\\\cdot \\\\vec T \\\\; ds$\")), mdx(\"p\", null, \"The normal vector $\\\\vec n$ is a unit vector on the positive side of the surface defined by parameterization.\\nSetting $\\\\vec n(p)$ as the normalized $\\\\vec r_u(u, v) \\\\times \\\\vec r_v(u, v)$.\"), mdx(\"p\", null, \"$$ \\\\vec n (p) := \\\\frac{\\\\vec r_u (u, v) \\\\times \\\\vec r_v (u, v)}{\\\\vert \\\\vec r_u (u, v) \\\\times \\\\vec r_v (u, v) \\\\vert}$$\"), mdx(\"h3\", {\n    \"id\": \"flow-and-flux\"\n  }, \"Flow and Flux\"), mdx(\"p\", null, \"In terminology, flux of $\\\\vec F$ is a surface integral\"), mdx(\"p\", null, \"and flow of $\\\\vec F$ over $C$ is a curve integral.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"a5f96dd9-3e03-58ce-a9ab-52dc0e2809cc","fields":{"slug":"/ma2104/surface-integrals","title":"Surface Integrals"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"curl-of-vector-field\"\n  }, \"Curl of Vector Field\"), mdx(\"p\", null, \"Curl is a differentiation of a vector field that gets another vector field.\"), mdx(\"p\", null, \"Let $U \\\\subseteq \\\\R^3$ be an open set in $\\\\R^3$.\\nand $\\\\vec F : U \\\\rightarrow \\\\R^3$ be a differentiable vector field.\"), mdx(\"p\", null, \"The curl of $\\\\vec F$ is the vector field $\\\\nabla \\\\times \\\\vec F : U \\\\rightarrow \\\\R^3$ given by for each $\\\\vec p \\\\in U$, \"), mdx(\"p\", null, \"$$(\\\\nabla \\\\times \\\\vec F)(\\\\vec p) := \\\\begin{pmatrix}\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"\\\\frac{\\\\partial P}{\\\\partial y}(\\\\vec p) - \\\\frac{\\\\partial N}{\\\\partial z}(\\\\vec p) \", \"\\\\\", \"\\n\\\\frac{\\\\partial M}{\\\\partial z}(\\\\vec p) - \\\\frac{\\\\partial P}{\\\\partial x}(\\\\vec p) \", \"\\\\\", \"\\n\\\\frac{\\\\partial N}{\\\\partial x}(\\\\vec p) - \\\\frac{\\\\partial M}{\\\\partial y}(\\\\vec p) \", \"\\\\\", \"\\n\\\\end{pmatrix}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Take $\\\\nabla = \\\\partial / (\\\\partial x, \\\\partial y, \\\\partial z)$ and do a cross product.\")), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"curl vector field\"), \" on $U$ is a vector field $\\\\vec G : U \\\\rightarrow \\\\R^3$ such that there exists a differentiable vector field $\\\\vec F : U \\\\rightarrow \\\\R^3$ such that $\\\\vec G = \\\\nabla \\\\times \\\\vec F$.\"), mdx(\"p\", null, \"When this is so, the vector field $\\\\vec F$ is called a vector potential of $\\\\vec G$.\"), mdx(\"h2\", {\n    \"id\": \"algebraic-rules-for-curls\"\n  }, \"Algebraic Rules for Curls\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sum rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Difference rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Constant multiple rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Product rule \", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$\\\\nabla \\\\times (f \\\\vec F) = f \\\\nabla \\\\times \\\\vec F + \\\\nabla f \\\\times \\\\vec F$\")))), mdx(\"h2\", {\n    \"id\": \"important-identity\"\n  }, \"Important Identity\"), mdx(\"p\", null, \"Let $U \\\\subseteq \\\\R^3$ be an open set in $\\\\R^3$\\nand $f: U \\\\rightarrow \\\\R$ be a twice continuously differentiable scalar-valued function on $U$.\"), mdx(\"p\", null, \"Then $\\\\nabla \\\\times (\\\\nabla f) = 0$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If $\\\\vec F$ is a gradient vector field, then $\\\\nabla \\\\times \\\\vec F = \\\\vec 0$\")), mdx(\"h2\", {\n    \"id\": \"stokes-theorem\"\n  }, \"Stoke's Theorem\"), mdx(\"hr\", null), mdx(\"h3\", {\n    \"id\": \"key-theorem-2\"\n  }, \"Key Theorem 2\"), mdx(\"p\", null, \"Let $S$ be a smooth surface in $\\\\R^3$,\\ngiven a smooth bijective parameterization.\"), mdx(\"p\", null, \"$$\\\\vec r : R \\\\rightarrow S$$\"), mdx(\"p\", null, \"where $R \\\\subseteq \\\\R^2$ is a compact rectangle\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The boundary $\\\\partial S$ of $S$ is then a piecewise smooth curve parameterized by the restriction of $\\\\vec r$ to the boundary $\\\\partial R$ of $R$.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Regard $\\\\partial R$ as a piecewise smooth (closed) curve in $\\\\R^2$ oriented counterclockwise.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This induces corresponding orientation on $\\\\partial S$.\")), mdx(\"h4\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"First prove the special case of Green's Theorem\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Then reduce the general case of Stoke's Theorem to the special case of Green's Theorem\")), mdx(\"hr\", null), mdx(\"p\", null, \"Let $D \\\\subseteq \\\\R^3$ be an open set with $S \\\\subseteq D$\\nand let $\\\\vec F : D \\\\rightarrow \\\\R^3$ be a continuously differentiable vector field.\\nThen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"S (\\\\nabla \\\\times \\\\vec F) \\\\cdot \\\\vec n \\\\; d \\\\sigma = \\\\int\"), \"{\\\\partial S} \\\\vec F \\\\cdot d \\\\vec r = \\\\int_{\\\\partial S} \\\\vec F \\\\cdot \\\\vec T \\\\; ds$$\"), mdx(\"p\", null, \"If 2 different oriented surfaces have the same boundary, their curl integrals are equal.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Stoke's Theorem also holds for oriented surfaces with holes\")), mdx(\"h2\", {\n    \"id\": \"greens-theorem\"\n  }, \"Green's Theorem\"), mdx(\"p\", null, \"Let $C$ be a piecewise smooth, simple closed curve enclosing a region $R$ in the plane.\\nLet $\\\\vec F = M \\\\vec i + N \\\\vec j$ be a vector field with $M$ and $N$ having continuous first partial derivatives in an open region containing $R$.\\nThen the counterclockwise circulation of $\\\\vec F$ around $C$ equals the double integral of $(\\\\nabla \\\\times \\\\vec F) \\\\cdot \\\\vec k$ over $R$.\"), mdx(\"p\", null, \"$$\\\\oint_C \\\\vec F \\\\cdot T \\\\; ds = \\\\oint_C M \\\\; dx + N \\\\; dy = \\\\iint_R \\\\Bigg(\\\\frac{\\\\partial N}{\\\\partial x} - \\\\frac{\\\\partial M}{\\\\partial y} \\\\Bigg ) \\\\; dx \\\\; dy$$\"), mdx(\"h1\", {\n    \"id\": \"divergence\"\n  }, \"Divergence\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"divergence-of-vector-fields\",\n    \"title\": \"Divergence of a Vector Field\"\n  }, \"divergence-of-vector-fields\"), \"]\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"8a89f3f8-b800-5421-9262-e7cd18591685","fields":{"slug":"/ma2104/curl-of-vector-field","title":"Curl of Vector Field"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"divergence-of-a-vector-field\"\n  }, \"Divergence of a Vector Field\"), mdx(\"p\", null, \"Let $U \\\\subseteq \\\\R^n$ be an open set in $\\\\R^n$\"), mdx(\"p\", null, \"and $\\\\vec F : U \\\\rightarrow \\\\R^n$ be a differentiable vector field,\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"divergence of\"), \" $\\\\vec F$ is the (scalar) function $\\\\nabla \\\\cdot \\\\vec F \\\\rightarrow \\\\R$ given by\"), mdx(\"p\", null, \"$$\\\\nabla \\\\cdot \\\\vec F = \\\\frac{\\\\partial F_1}{\\\\partial x_1} + ... + \\\\frac{\\\\partial F_n}{\\\\partial x_n}$$\"), mdx(\"p\", null, \"Thus $\\\\nabla \\\\cdot \\\\vec F$ is a function on $U$ is continuous iff $\\\\vec F$ is continuously differentiable.\"), mdx(\"h2\", {\n    \"id\": \"algebraic-rules-for-divergence\"\n  }, \"Algebraic Rules for Divergence\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sum Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Difference Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Constant multiple Rule \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Product Rule $\\\\nabla \\\\cdot (f \\\\vec F) = f(\\\\nabla \\\\cdot \\\\vec F) + (\\\\nabla f) \\\\cdot \\\\vec F$\")), mdx(\"h2\", {\n    \"id\": \"divergence-of-curl\"\n  }, \"Divergence of Curl\"), mdx(\"p\", null, \"If $\\\\vec F$ is a twice continuously differentiable vector field in $\\\\R^3$, then\"), mdx(\"p\", null, \"$$\\\\nabla \\\\cdot (\\\\nabla \\\\times \\\\vec F) = 0$$\"), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"Expand components.\"), mdx(\"h2\", {\n    \"id\": \"corollary-condition-for-curl\"\n  }, \"Corollary Condition for Curl\"), mdx(\"p\", null, \"If $\\\\vec F$ is a curl vector field, \"), mdx(\"p\", null, \"then $\\\\nabla \\\\cdot \\\\vec F = 0$\"), mdx(\"p\", null, \"Since $\\\\vec F = \\\\nabla \\\\times \\\\vec G$ implies $\\\\nabla \\\\cdot \\\\vec F = \\\\nabla \\\\cdot (\\\\nabla \\\\times \\\\vec G) = 0$\"), mdx(\"h2\", {\n    \"id\": \"divergence-theorem\"\n  }, \"Divergence Theorem\"), mdx(\"p\", null, \"Let $D$ be a compact region in $\\\\R^3$,\\nwhose boundary $\\\\partial D$ is a piecewise smooth surface.\"), mdx(\"p\", null, \"Let $\\\\vec F : D \\\\rightarrow \\\\R^3$ be a continuously differentiable vector field on $D$.\\nThen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"D (\\\\nabla \\\\cdot \\\\vec F) \\\\; dV = \\\\oint\"), \"{\\\\partial D} \\\\vec F \\\\cdot \\\\vec n \\\\; d \\\\sigma$$\"), mdx(\"p\", null, \"where the boundary $\\\\partial D$ is oriented with the unit normal vector field $\\\\vec n$ pointing outwards.\"), mdx(\"h3\", {\n    \"id\": \"proof-1\"\n  }, \"Proof\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"h3\", {\n    \"id\": \"divergence-theorem-in-r2\"\n  }, \"Divergence Theorem in $\\\\R^2$\"), mdx(\"p\", null, \"Let $D$ be a compact region in $\\\\R^2$,\\nwhose boundary $\\\\partial D$ is a piecewise smooth curve.\"), mdx(\"p\", null, \"Let $\\\\vec F : D \\\\rightarrow \\\\R^2$ be a continuously differentiable vector field on $D$.\\nThen\"), mdx(\"p\", null, \"$$\\\\int\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"R (\\\\nabla \\\\cdot \\\\vec F) \\\\; d(x, y) = \\\\oint\"), \"{\\\\partial R} \\\\vec F \\\\cdot \\\\vec n \\\\; ds$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"391b03b8-5494-5844-ab95-0781fe1e7d60","fields":{"slug":"/ma2104/divergence-of-vector-fields","title":"Divergence of a Vector Field"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"extreme-values\"\n  }, \"Extreme Values\"), mdx(\"p\", null, \"Basic Facts\"), mdx(\"p\", null, \"Let $R \\\\subseteq \\\\R^n$ be a region in Euclidean space\"), mdx(\"p\", null, \"Let $f: R \\\\rightarrow \\\\R$ be a function\"), mdx(\"p\", null, \"If $R$ is compact (close & bounded) and $f$ is continuous\\nthen there exists $p \\\\in \\\\R$ such that\\n$f(p)$ is the global maximum value of $f$ over $R$.\"), mdx(\"h2\", {\n    \"id\": \"local-maximum\"\n  }, \"Local Maximum\"), mdx(\"p\", null, \"Let $f(x, y)$ be defined on a region $R$ containing the point $(a, b)$.\\nThen\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f(a, b)$ is a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"local maximum\"), \" value of $f$ if $f(a, b) \\\\geq f(x, y)$ for all domain points $(x, y)$ in an open disk centered at $(a, b)$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f(a, b)$ is a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"local minimum\"), \" value of $f$ if $f(a, b) \\\\leq f(x, y)$ for all domain points $(x, y)$ in an open disk centered at $(a, b)$.\")), mdx(\"p\", null, \"$p \\\\in R$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"local maximum point\"), \" for $f$ iff\"), mdx(\"p\", null, \"$\\\\exists \\\\epsilon \\\\in \\\\R_{> 0}$ s.t. $\\\\forall q \\\\in R$ with $\\\\vert q - p \\\\vert < \\\\epsilon$, one has $f(q) \\\\leq f(p)$.\"), mdx(\"p\", null, \"When this is so, $f(p) \\\\in \\\\R$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"local maximum value\"), \" of $f$.\"), mdx(\"h2\", {\n    \"id\": \"first-derivative-test-for-local-extreme-values\"\n  }, \"First Derivative Test for Local Extreme Values\"), mdx(\"p\", null, \"Suppose $f: R \\\\rightarrow \\\\R$ is differentiable and $p \\\\in R$ is an interior point of $R$ which is local max/min point of $f$.\\nThen\"), mdx(\"p\", null, \"$$(\\\\nabla f)(\\\\vec p) = \\\\vec 0$$\"), mdx(\"h2\", {\n    \"id\": \"critical-point\"\n  }, \"Critical Point\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"critical point\"), \" of $f: R \\\\rightarrow \\\\R$ is an interior point $p \\\\in R$ of $R$ such that \"), mdx(\"p\", null, \"$$(\\\\nabla f)(\\\\vec p) = \\\\vec 0$$\"), mdx(\"p\", null, \"when this is so, $f(p) \\\\in \\\\R$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"critical value\"), \" of $f$\"), mdx(\"p\", null, \"Thus, by the first derivative test, all local max/min points of $f$ which are interior points of $R$ must be among the critical points of $f$.\"), mdx(\"h2\", {\n    \"id\": \"absolute-maxima-and-minima-on-closed-bounded-regions\"\n  }, \"Absolute Maxima and Minima on Closed Bounded Regions\"), mdx(\"p\", null, \"We organize the search for the absolute extrema of a continuous function $f(x, y)$ on a closed bounded region $R$ into 3 steps\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"List the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"interior points\"), \" of $R$ where $f$ may have local maxima and minima and evaluate $f$ at these points. These are the critical points of $f$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"List the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"boundary points\"), \" of $R$ where $f$ has local maxima and minima and evaluate $f$ at these points.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Look through the lists for the maximum and minimum values of $f$. These will be the absolute maximum and minimum values of $f$ on $R$.\")), mdx(\"h2\", {\n    \"id\": \"saddle-point\"\n  }, \"Saddle Point\"), mdx(\"p\", null, \"$p \\\\in R$ is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"saddle point\"), \" for $f$ iff\\n$p$ is a critical point for $f$ but $p$ is not a local maximum and local minimum for $f$.\"), mdx(\"h2\", {\n    \"id\": \"second-derivative-test-for-local-extreme-values\"\n  }, \"Second Derivative Test for Local Extreme Values\"), mdx(\"p\", null, \"Suppose that $f(x, y)$ and its first and second derivatives are continuous throughout a disk centered at $(a, b)$ and that $f_x(a, b) = f_y(a, b) = 0$.\\nThen\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f$ has a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"local maximum\"), \" at $(a, b)$ if $f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{xx} < 0$ and $f\"), \"{xx}f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{yy} - f\"), \"{xy}^2 > 0$ at $(a, b)$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f$ has a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"local minimum\"), \" at $(a, b)$ if $f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{xx} > 0$ and $f\"), \"{xx}f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{yy} - f\"), \"{xy}^2 > 0$ at $(a, b)$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$f$ has a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"saddle point\"), \" at $(a, b)$ if $f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{xx}f\"), \"{yy} - f_{xy}^2 < 0$ at $(a, b)$.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"test is inconclusive\"), \" at $(a, b)$ if $f\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{xx}f\"), \"{yy} - f_{xy}^2 = 0$ at $(a, b)$. In this case, we must find some other way to determine the behavior of $f$ at $(a, b)$.\")), mdx(\"h3\", {\n    \"id\": \"hessian\"\n  }, \"Hessian\"), mdx(\"p\", null, \"Determinant of square matrix of partial derivatives.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"65098e40-f3d2-5a96-b776-9a5c66db4286","fields":{"slug":"/ma2104/extreme-values","title":"Extreme Values"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"maxwell-equations\"\n  }, \"Maxwell Equations\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$$\\\\oint\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"S \\\\vec E \\\\circ \\\\hat n \\\\; ds = \\\\frac{q\"), \"{enc}}{\\\\epsilon_0}$$\")), mdx(\"p\", null, \"Electric charge produces an electric field, and the flux of that field passing through any closed surface is proportional to the total charge contained within that surface.\"), mdx(\"p\", null, \"$S = \\\\partial D$ is a closed surface\"), mdx(\"p\", null, \"$q_{enc}$ is the total amount of charge contained within that surface\"), mdx(\"p\", null, \"$e_0$ is the permittivity of free space\"), mdx(\"p\", null, \"$\\\\vec E$ is the electric field, the electrical force per unit charge exerted on a charged object.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"3f52094b-a3a6-5821-ba68-8057beee3642","fields":{"slug":"/ma2104/maxwell-equations","title":"Maxwell Equations"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"bubble-foader\"\n  }, \"Bubble Foader\"), mdx(\"p\", null, \"#entry\"), mdx(\"p\", null, \"\\uD83D\\uDC4B Welcome to my Foam Knowledge Base!\"), mdx(\"h2\", {\n    \"id\": \"navigation\"\n  }, \"Navigation\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"dingyuchen.github.io\"\n  }, \"blog\"), \" - This is where I keep my blog\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"inbox\",\n    \"title\": \"Inbox\"\n  }, \"inbox\"), \"] - a place to write down quick notes to be categorised later\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"] - a place to keep track of things I want/need to do\")), mdx(\"h3\", {\n    \"id\": \"modules\"\n  }, \"Modules\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"cs5228/module-cs5228\",\n    \"title\": \"module-cs5228\"\n  }, \"module-cs5228\"), \"] - CS5228 Knowledge Discovery and Data Mining\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"cs4212/module-cs4212\",\n    \"title\": \"Compiler Design\"\n  }, \"module-cs4212\"), \"] - CS4212 Compiler Design\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ma3269/module-ma3269\",\n    \"title\": \"Mathematical Finance 1\"\n  }, \"module-ma3269\"), \"] - MA3269 Mathematical Finance 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"cs5330/module-5330\",\n    \"title\": \"Randomized Algorithms\"\n  }, \"module-5330\"), \"] - CS5330 Randomized Algorithms\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"distributed-dyom/distributed-dyom\",\n    \"title\": \"Distributed Systems\"\n  }, \"distributed-dyom\"), \"] - DYOM Distributed Systems\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"st2131/module-2131\",\n    \"title\": \"Probability\"\n  }, \"module-2131\"), \"] - ST2131 Probability\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ma3110/module-ma3110\",\n    \"title\": \"Mathematical Analysis 2\"\n  }, \"module-ma3110\"), \"] - MA3110 Mathematical Analysis 2\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ma2101/module-ma2101\",\n    \"title\": \"Linear Algebra 2\"\n  }, \"module-ma2101\"), \"] - MA2101 Linear Algebra 2\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ma2104/module-ma2104\",\n    \"title\": \"Multivariable Calculus\"\n  }, \"module-ma2104\"), \"] - MA2104 Multivariable Calculus\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ma3252/module-ma3252\",\n    \"title\": \"Linear and Network Optimization\"\n  }, \"module-ma3252\"), \"] - MA3252 Linear and Network Optimization\")), mdx(\"h3\", {\n    \"id\": \"other-collections\"\n  }, \"Other Collections\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"misc/misc\",\n    \"title\": \"Miscellaneous\"\n  }, \"misc\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"making-your-own\"\n  }, \"Making your own\"), mdx(\"p\", null, \"This documentation assumes that you have a GitHub account and have \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://code.visualstudio.com/\"\n  }, \"Visual Studio Code\"), \" installed on your Linux/MacOS/Windows machine.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If you haven't yet, browse over to the main \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://foambubble.github.io/foam\"\n  }, \"Foam documentation workspace\"), \" to get an idea of what Foam is and how to use it.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Press \\\"Use this template\\\" button at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/mathieudutour/foam-gatsby-template/generate\"\n  }, \"foam-gatsby-template\"), \" to fork it to your own GitHub account. If you want to keep your thoughts to yourself, remember to set the repository private.\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"This creates a gatsby template instead of the vanilla one used by Foam. It supports backlinking and graph out of the box.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Unfortunately, it does not allow nested subfolders (pending PR merge) and latex.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://help.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository\"\n  }, \"Clone the repository to your local machine\"), \" and open it in VS Code.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Open the repository as a folder using the \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"File > Open...\"), \" menu item.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"When prompted to install recommended extensions, click \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Install all\"), \" (or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Show Recommendations\"), \" if you want to review and install them one by one)\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Open \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"_layouts/gatsby-config.js\"\n  }, \"_layouts/gatsby-config.js\"), \" and edit the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pathPrefix\"), \" to be the name of the repository.\"))), mdx(\"p\", null, \"After setting up the repository, head to [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"getting-started\",\n    \"title\": \"Getting Started\"\n  }, \"getting-started\"), \"] to get familiar with your new knowledge base!\"), mdx(\"p\", null, \"To learn more about how to use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Foam\"), \", read the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://foambubble.github.io/foam/recipes/recipes\"\n  }, \"Recipes\"), \" bubbles of the Foam documentation workspace.\"), mdx(\"p\", null, \"And remember that you can always join our  \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://discord.gg/HV2tn2FpEk\"\n  }, \"Foam community on Discord\"), \"!\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"b97941cc-9f81-5bf4-85d9-dcd0172036fd","fields":{"slug":"/readme","title":"Bubble Foader"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"lengths-and-angles\"\n  }, \"Lengths and Angles\"), mdx(\"h2\", {\n    \"id\": \"dot-product\"\n  }, \"Dot Product\"), mdx(\"p\", null, \"Dot product as per the classical definition.\"), mdx(\"h3\", {\n    \"id\": \"length\"\n  }, \"Length\"), mdx(\"p\", null, \"If $u \\\\in \\\\R^3$, then the length of $u$ is \"), mdx(\"p\", null, \"$$\\\\vert u \\\\vert = \\\\sqrt{u \\\\cdot u}$$\"), mdx(\"h3\", {\n    \"id\": \"angle\"\n  }, \"Angle\"), mdx(\"p\", null, \"If $u \\\\neq 0$ and $v \\\\neq 0$, then the angle between $u$ and $v$ is defined as \"), mdx(\"p\", null, \"$$\\\\cos (\\\\theta) = \\\\frac{u \\\\cdot v}{\\\\vert u \\\\vert \\\\vert v \\\\vert}$$\"), mdx(\"h3\", {\n    \"id\": \"property-of-dot-products\"\n  }, \"Property of Dot products\"), mdx(\"p\", null, \"The standard dot product clearly satisfies these conditions\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$u \\\\cdot u \\\\geq 0 \\\\forall u \\\\in \\\\R^n$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$u \\\\cdot u = 0 \\\\leftrightarrow u = 0$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$u \\\\cdot v = v \\\\cdot u, \\\\forall u, v \\\\in \\\\R^n$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It is linear in both \\\"slots\\\"\")), mdx(\"h2\", {\n    \"id\": \"bilinear-forms\"\n  }, \"Bilinear Forms\"), mdx(\"p\", null, \"Recall that a dual vector is a mapping that takes in a vector and returns a scalar.\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"bilinear form\"), \" on a finite-dimension vector space $V$ is a mapping $g$ from $V \\\\times V$ to $\\\\R$ which is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"linear\"), \" in both slots, that is,\\nif $u, v, w \\\\in V$ and $a, b \\\\in \\\\R$, then  \"), mdx(\"p\", null, \"$$g(au + bv, w) = ag(u, w) + bg(v, w)$$\\n$$g(w, au + bv) = ag(w, u) + bg(w, v)$$\"), mdx(\"h3\", {\n    \"id\": \"fact\"\n  }, \"Fact\"), mdx(\"p\", null, \"The set of bilinear forms $\\\\mathbf{B}(V)$, is a vector space.\"), mdx(\"p\", null, \"So if $g, h \\\\in \\\\mathbf{B}(V)$, then\"), mdx(\"p\", null, \"$$(g + h)(u, v) = g(u, v) + h(u, v)$$\"), mdx(\"h3\", {\n    \"id\": \"tensor-product-of-dual-vectors\"\n  }, \"Tensor Product of Dual Vectors\"), mdx(\"p\", null, \"Let $\\\\alpha, \\\\beta \\\\in \\\\hat V$, and let $u, v$ be any vectors in $V$.\\nThen the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"tensor product\"), \" of $\\\\alpha$ with $\\\\beta$, is the element of $\\\\mathbf{B}(V)$,\"), mdx(\"p\", null, \"$$\\\\alpha \\\\otimes \\\\beta (u, v) = \\\\alpha(u) \\\\beta(v)$$\"), mdx(\"p\", null, \"Now let $z_i$ be a basis for $V$, and let $\\\\zeta^j$ be the dual basis.\"), mdx(\"p\", null, \"For each pair of indices $(i, j)$, $\\\\zeta^i \\\\otimes \\\\zeta^j$ is a bilinear form.\"), mdx(\"h3\", {\n    \"id\": \"basis-for-bilinear-forms\"\n  }, \"Basis for Bilinear Forms\"), mdx(\"p\", null, \"Any bilinear form on $V$ can be expressed as in the form $g_{ij} \\\\zeta^i \\\\otimes \\\\zeta^j$.\"), mdx(\"p\", null, \"The full set $\\\\zeta^i \\\\otimes \\\\zeta^j$ (with $i, j$ taking all possible values) is a basis for $\\\\mathbf{B}(V)$.\"), mdx(\"p\", null, \"To see this, let $g$ be any bilinear form on $V$ and think about $g(z_i, z_j)$.\"), mdx(\"p\", null, \"Any bilinear form on $V$ can be expressed  in the form $g\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{ij} \\\\zeta^i \\\\otimes \\\\zeta^j$.\\nThe numbers $g\"), \"{ij}$ are called the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"components\"), \" of $g$ relative to the basis $z_i$.\"), mdx(\"h3\", {\n    \"id\": \"convention\"\n  }, \"Convention\"), mdx(\"p\", null, \"We can arrange the components of a bilinear form into a matrix.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"441px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/efc6e/2021-04-07-15-42-30.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"50%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABPUlEQVQoz5VS2YqDQBDM//9SQETy4AUSYkAlPgSJCBGPXB4x6WwVtJjdpy0Yp9vpo6pnVvKD9/s9r//g9XqJ5uu+UqcoCnk8HjIMgzyfzzmo6zqZpokL/3A+jiPPLpeLlGX5VXSFT9/3kqYpd9M0JQxDNgAMw5DdbsdzMPJ9X7bbLVfTNHI4HGa2ZKid4jjmAVi2bctdGcJHjDa/Xq/0YUdR9C0ZBgK0YFVVlKUzRTEdg8bebjeOANKRB/tPwSRJSHu9Xstms5Hj8cggy7I4hiAI6LuuS99xHLnf78yDCr2gWTKoK9BJA5bz+Q0wRN7ytllQOwFgdj6fKRM4nU70IR2Anec5/WWejmh+NlmWSV3XYtu2eJ7HQgBs/Nvv90zA7UIudsSj+NezUQP09X1Bgg4a0He4HAEWVCwvBOsDibn/TUEWlXcAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"2021 04 07 15 42 30\",\n    \"title\": \"2021 04 07 15 42 30\",\n    \"src\": \"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/efc6e/2021-04-07-15-42-30.png\",\n    \"srcSet\": [\"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/0d3e1/2021-04-07-15-42-30.png 140w\", \"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/6b1e2/2021-04-07-15-42-30.png 281w\", \"/foader/static/d9f5f5bdb6dc6d5d32ef68055bb14897/efc6e/2021-04-07-15-42-30.png 441w\"],\n    \"sizes\": \"(max-width: 441px) 100vw, 441px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"This is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"matrix of the bilinear form relative to the basis\"), \" $z_i$.\"), mdx(\"h1\", {\n    \"id\": \"inner-product\"\n  }, \"Inner Product\"), mdx(\"p\", null, \"An \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"inner product space\"), \" is a pair $(V, g)$ consisting of a vector space $V$ and a bilinear form $g$, called an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"inner product\"), \" on $V$, with the following properties\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, u) \\\\geq 0 \\\\; \\\\forall u \\\\in V$ (positivity)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, u) = 0$ iff $u = 0$. (definiteness)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, v) = g(v, u) \\\\; \\\\forall u, v \\\\in V$ (symmetry)\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$g$ is not unique. We choose a $V$ we want to study, then select a $g$.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Set of inner products on $V$ is not a subspace\"), mdx(\"blockquote\", {\n    parentName: \"blockquote\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Zero \\\"vector\\\" does not satisfy definiteness\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Negative scalar of an inner product does not satisfy positivity.\"))), mdx(\"h2\", {\n    \"id\": \"length-and-angles-again\"\n  }, \"Length and Angles again\"), mdx(\"p\", null, \"Let $(V, g)$ be an inner product space.\\nThe \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"length\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"norm\"), \" of a vector $v \\\\in V$ is defined\"), mdx(\"p\", null, \"$$\\\\vert v \\\\vert  = \\\\sqrt{g(v, v)}$$\"), mdx(\"p\", null, \"where the square root is the non negative one.\"), mdx(\"hr\", null), mdx(\"p\", null, \"Vectors $u, v \\\\in V$ are said to be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"orthogonal\"), \" if $g(u, v) = 0$.\"), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"orthogonal-decomposition\"\n  }, \"Orthogonal Decomposition\"), mdx(\"p\", null, \"Any vector in an inner product space can be written as\"), mdx(\"p\", null, \"$$u = \\\\frac{g(u, v)}{\\\\vert u \\\\vert^2} + \\\\Bigg ( u - \\\\frac{g(u, v)}{\\\\vert v \\\\vert^2} v \\\\Bigg )$$\"), mdx(\"p\", null, \"where $v$ is any non-zero vector.\"), mdx(\"h2\", {\n    \"id\": \"cauchy-schwarz-inequality\"\n  }, \"Cauchy-Schwarz Inequality\"), mdx(\"p\", null, \"If $u, v \\\\in V$, where $(V, g)$ is an inner product space,\\nthen\"), mdx(\"p\", null, \"$$\\\\vert g(u, v) \\\\vert \\\\leq \\\\vert u \\\\vert \\\\vert v \\\\vert $$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Furthermore, this inequality is only equal if 1 vector is a scalar multiple of another.\")), mdx(\"p\", null, \"Related to [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../ma2104/cauchy-schwarz-inequality\",\n    \"title\": \"Cauchy-Schwarz Inequality\"\n  }, \"cauchy-schwarz-inequality\"), \"] for [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../ma2104/module-ma2104\",\n    \"title\": \"Multivariable Calculus\"\n  }, \"module-ma2104\"), \"].\"), mdx(\"h3\", {\n    \"id\": \"triangle-inequality\"\n  }, \"Triangle Inequality\"), mdx(\"p\", null, \"if $(V, g)$ is an inner product space (so that we can take norm of $v$) and $u, v \\\\in V$, then \"), mdx(\"p\", null, \"$$ \\\\vert u + v \\\\vert \\\\leq \\\\vert u \\\\vert + \\\\vert v \\\\vert$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The inequality is equal iff one vector is a non-negative multiple of the other.\")), mdx(\"h3\", {\n    \"id\": \"angles\"\n  }, \"Angles\"), mdx(\"p\", null, \"Let $(V, g)$ be an inner product space, and let $u, v$ be vectors in $V$.\\nThen the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"angle\"), \" between $u$ and $v$, $\\\\theta$, is defined as the number between $0$ and $\\\\pi$ inclusive that satisfies\"), mdx(\"p\", null, \"$$\\\\cos (\\\\theta) = \\\\frac{g(u, b)}{\\\\vert u \\\\vert \\\\vert v \\\\vert}$$\"), mdx(\"h2\", {\n    \"id\": \"orthonormal-basis\"\n  }, \"Orthonormal Basis\"), mdx(\"p\", null, \"Let $(V, g)$ be an inner product space, and let $z_i$ be a basis.\\nThen $z_i$ is said to be an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"orthonormal\"), \" basis if, for all $i, j$, we have\"), mdx(\"p\", null, \"$$g(z\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i, z_j) = I\"), \"{ij}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The matrix of an inner product, regarded as a bilinear form, relative to an orthonormal basis is the identity matrix.\")), mdx(\"h2\", {\n    \"id\": \"gram-schmidt-orthogonalization\"\n  }, \"Gram-Schmidt Orthogonalization\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Every (finite-dimensional) inner product space has an orthonormal basis.\")), mdx(\"h2\", {\n    \"id\": \"riez-representation\"\n  }, \"Riez Representation\"), mdx(\"p\", null, \"Let $(V, g)$ be an inner product space, and let $u \\\\in V$.\\nDefine a dual vector $\\\\Gamma_u$ by\"), mdx(\"p\", null, \"$$\\\\Gamma_u(v) := g(u, v) \\\\; \\\\forall v \\\\in V$$\"), mdx(\"p\", null, \"Thus the inner product allows us to turn the vector $u$ into a dual vector $\\\\Gamma_u$.\\nThe mapping \"), mdx(\"p\", null, \"$$\\\\Gamma : u \\\\rightarrow \\\\Gamma_u$$\"), mdx(\"p\", null, \"is a mapping from $V$ to $\\\\hat V$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This mapping is an isomorphism\")), mdx(\"h3\", {\n    \"id\": \"riez-representation-theorem\"\n  }, \"Riez Representation Theorem\"), mdx(\"p\", null, \"In an inner product space $(V, g)$, any dual vector $\\\\alpha$ can be expressed as $\\\\Gamma(u)$ for some unique $u \\\\in V$.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The matrix $g_{jk}$ can be solved\")), mdx(\"h1\", {\n    \"id\": \"the-complex-case\"\n  }, \"The Complex Case\"), mdx(\"p\", null, \"If $H$ is any complex number, then it has a complex conjugate $\\\\bar H$,\\nand then $H \\\\bar H$ is always real, and always positive.\"), mdx(\"p\", null, \"Take the dot product of $u, v$ to be $u \\\\cdot \\\\bar v$.\\nThat is, the second vector is mapped to its complex conjugate on all components.\"), mdx(\"p\", null, \"This makes the length or norm of a vector, defined as $dot(u, u)$, to always be positive and real.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"You want the length to be real so that you can make statements ordering the length of different vectors\")), mdx(\"p\", null, \"However, this means that the dot product is no longer commutative.\"), mdx(\"p\", null, \"Constants in the second \\\"slot\\\" would also have to be converted to its complex conjugate to bring it out of the bracket.\"), mdx(\"p\", null, \"$$u \\\\cdot (cv) = \\\\bar c u \\\\cdot v$$\"), mdx(\"h2\", {\n    \"id\": \"sesquilinear-form\"\n  }, \"Sesquilinear Form\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sesquilinear form\"), \" on a complex vector space $V$ is a mapping $g$ from $V \\\\times V$ to $\\\\mathcal{C}$ which is linear on the first slot,\\nbut \\\"conjugate-linear\\\" in the second slot.\"), mdx(\"p\", null, \"That is, for any $u, v  \\\\in V, c \\\\in \\\\mathcal{C}$, we have\"), mdx(\"p\", null, \"$$g(cu, v) = cg(u, v)$$\\n$$g(u, cv) = \\\\bar cg(u, v)$$\"), mdx(\"hr\", null), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"complex inner product space\"), \" is a pair $(V, g)$ consisting of a complex vector space $V$ and a sesquilinear form $g$ that satisfies\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, u) \\\\geq 0 \\\\; \\\\forall u \\\\in V$ (positivity)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, u) = 0$ iff $u = 0$ (definiteness)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$g(u, v) = \\\\overline{g(v, u)} \\\\; \\\\forall u, v \\\\in V$ (conjugate symmetry)\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Cauchy-Schwarz and Pythagoras and orthogonal decomposition still works the same.\")), mdx(\"h2\", {\n    \"id\": \"riez-representation-theorem-for-complex\"\n  }, \"Riez Representation Theorem for Complex\"), mdx(\"p\", null, \"Define $\\\\Gamma_u(v) := g(v, u)$.\\nThis allows for linearity.\"), mdx(\"p\", null, \"However, $\\\\Gamma : u \\\\rightarrow \\\\Gamma_u$ is not a vector space isomorphism.\"), mdx(\"h3\", {\n    \"id\": \"conjugate-isomorphism\"\n  }, \"Conjugate Isomorphism\"), mdx(\"p\", null, \"Let $V$ and $W$ be complex vector spaces.\\nA \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"conjugate isomorphism\"), \" $F: V \\\\rightarrow W$ is a bijective map that satisfies\"), mdx(\"p\", null, \"$$F(au + bv) = \\\\bar a F(u) + \\\\bar bF(v) \\\\; \\\\forall a, b \\\\in \\\\mathcal{C}, u, v, \\\\in V$$\"), mdx(\"p\", null, \"So $\\\\Gamma$ is a conjugate isomorphism instead of an isomorphism.\"), mdx(\"h2\", {\n    \"id\": \"schurs-theorem\"\n  }, \"Schur's Theorem\"), mdx(\"p\", null, \"Given a linear operator $T$ on a finite-dimensional complex inner product space, there exists an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"orthonormal\"), \" basis with respect to which $T$ has an upper-triangular matrix.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The product of upper-triangular matrices is upper-triangular.\")), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"Over $C$, every linear operator has an upper-triangular matrix with respect to some basis of $V$.\"), mdx(\"p\", null, \"Then it also has an upper-triangular matrix with respect to some orthonormal basis of $V$.\"), mdx(\"h1\", {\n    \"id\": \"spectral-theorem\"\n  }, \"Spectral Theorem\"), mdx(\"p\", null, \"The existence of an inner product on a vector space allows us to think of vectors as dual vectors.\"), mdx(\"p\", null, \"Thinking of linear transformations as bilinear/sesquilinear forms.\"), mdx(\"p\", null, \"Let $T$ be an operator on teh complex inner product space $(V, g)$. Then define a bilinear/sesquilinear form $\\\\tau$ by\"), mdx(\"p\", null, \"$$T(u, v) := g(u, Tv), \\\\forall u, v \\\\in V$$\"), mdx(\"h3\", {\n    \"id\": \"hermitian-symmetric-transformation\"\n  }, \"Hermitian (Symmetric) Transformation\"), mdx(\"p\", null, \"A bilinear/sesquilinearform is said to be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hermitian\"), \"  or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"symmetric\"), \" if for all $u, v \\\\in V$, we have\"), mdx(\"p\", null, \"$$\\\\tau(u, v) = \\\\overline{\\\\tau (v, u)}$$\"), mdx(\"p\", null, \"A linear transformation $T$ on an inner product space is called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hermitian\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"symmetric\"), \" if its corresponding sesquilinear/bilinear form is hermitian/symmetric.\"), mdx(\"p\", null, \"ie, $T$ satisfies\"), mdx(\"p\", null, \"$$g(u, Tv) = \\\\tau(u, v) = \\\\overline{\\\\tau (v, u)} = \\\\overline{g(v, Tu)} = g(Tu, v) \\\\; \\\\forall u, v \\\\in V$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If we use an orthonormal basis, then the matrices of $T$ and $\\\\tau$ are the same.\")), mdx(\"h3\", {\n    \"id\": \"eigenvalues\"\n  }, \"Eigenvalues\"), mdx(\"p\", null, \"The eigenvalues of a symmetric/Hermitian linear transformation are real.\"), mdx(\"h4\", {\n    \"id\": \"proof-1\"\n  }, \"Proof\"), mdx(\"p\", null, \"We have\"), mdx(\"p\", null, \"$$g(u, Tu) = g(u, \\\\lambda u) = \\\\bar \\\\lambda g(u, u)$$\"), mdx(\"p\", null, \"and \"), mdx(\"p\", null, \"$$g(u, Tu) = g(Tu, u) = \\\\lambda g(u, u)$$\"), mdx(\"p\", null, \"Since $g$ is definite and eigenvectors are not the zero vector,\\nwe have $g(u, u) \\\\neq 0$.\"), mdx(\"p\", null, \"So we can divide and conclude that $\\\\bar \\\\lambda = \\\\lambda$.\"), mdx(\"h3\", {\n    \"id\": \"complex-spectral-theorem\"\n  }, \"(Complex) Spectral Theorem\"), mdx(\"p\", null, \"Any Hermitian linear transformation $T$ on a complex inner product space has a real, diagonal matrix relative to some orthonormal basis.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Applies for symmetric linear transformation on real vector spaces.\")), mdx(\"h4\", {\n    \"id\": \"proof-2\"\n  }, \"Proof\"), mdx(\"p\", null, \"First put the matrix of $T$ into upper triangular form with respect to an orthonormal basis;\"), mdx(\"p\", null, \"Since $T$ and $\\\\tau$ are complex conjugates of each other, the associated sesquilinear form is also upper-triangular and is Hermitian.\"), mdx(\"p\", null, \"But those entries are zero, so both the lower and upper triangle are zero.\\nSo the matrix is diagonal.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"70c1bda2-8a7e-570b-a747-7d1949e619e6","fields":{"slug":"/ma2101/lengths-and-angles","title":"Lengths and Angles"}}}]},"fields":{"slug":"/ma2104/module-ma2104","title":"Multivariable Calculus"}}},"pageContext":{"id":"4667b8ff-5878-5615-8823-9a1a640cc0db"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}