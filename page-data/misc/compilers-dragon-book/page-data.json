{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/misc/compilers-dragon-book","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"compilers-principles-techniques-and-tools\"\n  }, \"Compilers: Principles, Techniques and Tools\"), mdx(\"h2\", {\n    \"id\": \"language-processes\"\n  }, \"Language Processes\"), mdx(\"p\", null, \"A compiler is a program that transforms a program in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"source language\"), \" to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"target language\"), \".\"), mdx(\"p\", null, \"A compiled program is usually much faster than an interpreted one, but the latter can usually give better diagnostics, since the source program is executed line by line.\"), mdx(\"p\", null, \"Other additional components include (in order of pipeline):\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Preprocessor\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Collect separate files into 1 program\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Expand macros\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Assembler\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Produces relocatable machine code\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Linker\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Link compiled pieces\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Resolve external memory addresses\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Loader\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Puts executable object files into memory for execution\")))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"What advantages are there to a language processing system in which the compiler produces assembly language rather than machine language?\")), mdx(\"h2\", {\n    \"id\": \"structure-of-a-compiler\"\n  }, \"Structure of a Compiler\"), mdx(\"p\", null, \"2 parts to compilation:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Analysis\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Synthesis\")), mdx(\"h3\", {\n    \"id\": \"analysis\"\n  }, \"Analysis\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"analysis\"), \" part breaks up the source program into constituent pieces and imposes a grammatical structure on them.\\nIt then uses this structure to create an intermediate representation of the source program.\"), mdx(\"p\", null, \"The analysis part also collects information about the source program and stores it in a data structure called a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"symbol table\"), \". \"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"miscellaneous\"\n  }, \"Miscellaneous\"), mdx(\"p\", null, \"#entry\"), mdx(\"h2\", {\n    \"id\": \"untethered-notes\"\n  }, \"Untethered Notes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"docker-notes\",\n    \"title\": \"Docker for Local Development Environments\"\n  }, \"docker-notes\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"compilers-dragon-book\",\n    \"title\": \"Compilers: Principles, Techniques and Tools\"\n  }, \"compilers-dragon-book\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"papers\"\n  }, \"Papers\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"sherlock-paper\",\n    \"title\": \"SherLock: Unsupervised Synchronization-Operation Inference\"\n  }, \"sherlock-paper\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"canopy-paper\",\n    \"title\": \"Canopy: An End-to-End Performance Tracing and Analysis System\"\n  }, \"canopy-paper\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"motivational-poems\"\n  }, \"Motivational Poems\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"the-will-to-win\",\n    \"title\": \"The Will to Win\"\n  }, \"the-will-to-win\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"invictus\",\n    \"title\": \"Invictus\"\n  }, \"invictus\"), \"]\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"472dc42c-92a7-5639-84ec-5227f9af8c38","fields":{"slug":"/misc/misc","title":"Miscellaneous"}}}]},"fields":{"slug":"/misc/compilers-dragon-book","title":"Compilers: Principles, Techniques and Tools"}}},"pageContext":{"id":"d57881fd-539e-53f6-83ba-4316ecc0cc6c"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}