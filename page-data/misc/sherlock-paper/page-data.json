{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/misc/sherlock-paper","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"sherlock-unsupervised-synchronization-operation-inference\"\n  }, \"SherLock: Unsupervised Synchronization-Operation Inference\"), mdx(\"h2\", {\n    \"id\": \"problem-formulation\"\n  }, \"Problem Formulation\"), mdx(\"p\", null, \"Synchronization helps to enforce a happens-before relationship.\"), mdx(\"p\", null, \"Many tools that analyze concurrent programs rely on understanding the semantics of program synchronization and the happen-before relationship induced by them.\\nTypically, these tools rely on manual specification.\"), mdx(\"p\", null, \"Low-level primitives like atomic operations do not always enforce a happen-before relationship.\\nThreading and locking APIs are complex and semantic-rich, making it difficult to annotate.\"), mdx(\"p\", null, \"Synchronization inference is a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dynamic unsupervised\"), \" probabilistic inference problem.\\nSherLock is a tool for identifying program synchronizations.\"), mdx(\"h3\", {\n    \"id\": \"high-level-idea\"\n  }, \"High Level Idea\"), mdx(\"p\", null, \"At a high level, SherLock is based on the idea that all synchronizations are used to order events that would otherwise result in bugs.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"What if result of program execution is independent on synchronization?\")), mdx(\"p\", null, \"SherLock identifies synchronizations by relying on the following insights:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Most (if not all) such conflicting accesses in mature programs are properly synchronized.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Design a set of properties and hypotheses that reflect assumptions of synchronizations and their behavior. Pinpoint synchronizations through multiple executions.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Perturb the execution at strategic locations to improve inference.\")), mdx(\"h3\", {\n    \"id\": \"components-of-sherlock\"\n  }, \"Components of SherLock\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Observer\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"This component instruments software binaries and produces execution traces under the provided inputs.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Solver\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Processes all the observations collected\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Identifies a set of acquire and release synchronizations\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Linear Solver\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Perturber\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Inject delays at strategic points of execution\")))), mdx(\"h1\", {\n    \"id\": \"what-are-synchronization-behaviors\"\n  }, \"What Are Synchronization Behaviors\"), mdx(\"p\", null, \"Identifying synchronizations without understanding the semantics of underlying framework, library, or operating system that implements them.\"), mdx(\"h2\", {\n    \"id\": \"definition\"\n  }, \"Definition\"), mdx(\"p\", null, \"Any instruction or operation in the application that enforces a happen-before relation across threads.\"), mdx(\"p\", null, \"In this paper, we consider every synchronization, acquire or release, to take one of these forms:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"read of a heap variable\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"write to a heap variable\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"an invocation or entry point of an API or method\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"exit of an API or method\")), mdx(\"h2\", {\n    \"id\": \"properties\"\n  }, \"Properties\"), mdx(\"p\", null, \"Hard constraints\"), mdx(\"h3\", {\n    \"id\": \"read-acquire-and-write-release\"\n  }, \"Read-Acquire and Write-Release\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"heap read does not change system states and hence cannot be a release synchronization\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"heap write cannot perceive what is going on in the system, hence cannot be an acquire synchronization\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"method's exit as a release;\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"method's invocation as an acquire - never the other way round\")), mdx(\"h2\", {\n    \"id\": \"hypotheses\"\n  }, \"Hypotheses\"), mdx(\"h3\", {\n    \"id\": \"mostly-protected\"\n  }, \"Mostly Protected\"), mdx(\"p\", null, \"Most, if not all, conflicting accesses in a mature software should be synchronized.\"), mdx(\"h3\", {\n    \"id\": \"synchronizations-are-rare\"\n  }, \"Synchronizations are Rare\"), mdx(\"p\", null, \"Synchronizations should constitute a small portion of all operations.\"), mdx(\"p\", null, \"It is unlikely for the same synchronization to occur many times.\"), mdx(\"h3\", {\n    \"id\": \"acquisition-time-mostly-varies\"\n  }, \"Acquisition-Time Mostly Varies\"), mdx(\"p\", null, \"How long a thread needs to wait during an acquire varies a lot at runtime.\"), mdx(\"p\", null, \"If every execution of a method $m$ takes roughly the same amount of time, the invocation of $m$ is unlikely to be an acquire.\"), mdx(\"h3\", {\n    \"id\": \"mostly-paired\"\n  }, \"Mostly Paired\"), mdx(\"p\", null, \"Given the strong semantic connection between a release and its corresponding acquire, they are often defined in a paired or clustered way in well-maintained software.\"), mdx(\"p\", null, \"Specifically, if the read of a variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C::v\"), \" is used for acquire synchronization, the corresponding release synchronization is very likely the write of the same variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C::v\"), \".\"), mdx(\"h2\", {\n    \"id\": \"interesting-behaviors\"\n  }, \"Interesting Behaviors\"), mdx(\"p\", null, \"In every run, SherLock injects delays around those top synchronization candidates based on previous runs so that the software's reaction towards these delays can either strongly support or dispute existing inference results.\"), mdx(\"p\", null, \"True synchronizations to surface after 1-3 runs.\"), mdx(\"h1\", {\n    \"id\": \"sherlock-implementation\"\n  }, \"SherLock Implementation\"), mdx(\"h2\", {\n    \"id\": \"observer\"\n  }, \"Observer\"), mdx(\"p\", null, \"SherLock instruments a given application to trace 2 types of operations during run time.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Read/write operations that may form conflicting-access pairs useful for Mostly-Paired Hypothesis.\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"read from or write to heap variables (public fields of a class)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"getter and setter methods of public properties of a class\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"invocations of read/write APIs of thread-unsafe libraries (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.add()\"), \")\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Accesses to heap variables and entry and exit of methods\")), mdx(\"h3\", {\n    \"id\": \"log-entry-content\"\n  }, \"Log Entry Content\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"timestamp\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"threadID\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"operation type \", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"read\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"write\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"method entry\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"method exit\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"field name and its memory address for each read/write operation\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"method name and parent object id for each method entry/exit operation\")), mdx(\"h3\", {\n    \"id\": \"forming-acquirerelease-windows\"\n  }, \"Forming acquire/release windows\"), mdx(\"p\", null, \"SherLock uses a physical time window \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Near\"), \" to filter out less useful pairs.\"), mdx(\"p\", null, \"Set a limit to the maximum time between 2 conflicting accesses.\"), mdx(\"p\", null, \"SherLock sets an upper bound (15) for the number of windows that one location pair can form.\"), mdx(\"h2\", {\n    \"id\": \"solver\"\n  }, \"Solver\"), mdx(\"h3\", {\n    \"id\": \"overall-objective-function\"\n  }, \"Overall objective function\"), mdx(\"p\", null, \"$$\\\\sum_w (rel(w) + acq(w)) + \\\\lambda \\\\bigg \", \"[\\\\sum_c pair_c(c) + \\\\sum_f pair_f(f) + \\\\sum_v reg(v) + \\\\sum_v rare(v) + \\\\sum_m var(m) \\\\bigg]\", \"$$\"), mdx(\"p\", null, \"At least one variable in the acquire/release window to be an acquire/release, number of synchronizations should also be minimized.\\nThis together prevents trivial solutions.\"), mdx(\"h2\", {\n    \"id\": \"perturber-and-feedback\"\n  }, \"Perturber and Feedback\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Adding new variables and corresponding constraints if new synchronization candidates show up\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Adding new objective function terms for every newly observed release window\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Updating existing objective function terms, eg. average occurrence of a candidate operation, the co-efficient of variance of a method's duration, etc.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"How are new candidates detected?\")), mdx(\"h3\", {\n    \"id\": \"data-race\"\n  }, \"Data race\"), mdx(\"p\", null, \"This occurs when SherLock observes a concurrent execution of two conflicting accesses with every operation in the acquire (release) window guaranteed to not be an acquire (release) synchronization.\\nThis can happen when either the acquire (release) window is empty or every operation in the window is a write (read) operation.\"), mdx(\"p\", null, \"SherLock remembers and removes all the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Mostly Protected\"), \" penalty term associated with the acquire and release windows between $a$ and $b$ in all runs.\"), mdx(\"p\", null, \"After every run, the Perturber injects a 100ms delay right before every dynamic instance of every operation that is currently considered as a release synchronization by the solver.\"), mdx(\"h1\", {\n    \"id\": \"results\"\n  }, \"Results\"), mdx(\"p\", null, \"SherLock successfully identifies many real synchronizations.\\nOf the 133 synchronizations identified, 122 are unique across the applications.\"), mdx(\"p\", null, \"Outperforms FastTrack\"), mdx(\"h2\", {\n    \"id\": \"missed-synchronizations\"\n  }, \"Missed Synchronizations\"), mdx(\"p\", null, \"For example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UpgradeToWriteLock\"), \" releases a reader lock and then acquires a writer lock all inside one API.\\nThis resulted in 1 missed synchronization and 15 false data-race reports.\"), mdx(\"p\", null, \"Future SherLock can try turning the Single-Role assumption into a soft constraint.\"), mdx(\"p\", null, \"Inability to refine the windows effectively.\\nThese include failures to identify the acquire pair for object disposals, the release pair for static constructors, and other synchronization.\\nFor instance, dispose functions are often called during garbage collection which can execute at a much later time after the pairing release instruction that removes the last reference to the object.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"miscellaneous\"\n  }, \"Miscellaneous\"), mdx(\"p\", null, \"#entry\"), mdx(\"h2\", {\n    \"id\": \"untethered-notes\"\n  }, \"Untethered Notes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"docker-notes\",\n    \"title\": \"Docker for Local Development Environments\"\n  }, \"docker-notes\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"compilers-dragon-book\",\n    \"title\": \"Compilers: Principles, Techniques and Tools\"\n  }, \"compilers-dragon-book\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"shopee-entry-task-presentation\",\n    \"title\": \"Shopee Entry Task Presentation\"\n  }, \"shopee-entry-task-presentation\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"less-quanta-motion-app\",\n    \"title\": \"Less Quanta - Motion\"\n  }, \"less-quanta-motion-app\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"papers\"\n  }, \"Papers\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"sherlock-paper\",\n    \"title\": \"SherLock: Unsupervised Synchronization-Operation Inference\"\n  }, \"sherlock-paper\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"canopy-paper\",\n    \"title\": \"Canopy: An End-to-End Performance Tracing and Analysis System\"\n  }, \"canopy-paper\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"microbat-instrumentator-tech-spec\",\n    \"title\": \"Microbat Tech Spec\"\n  }, \"microbat-instrumentator-tech-spec\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"motivational-poems\"\n  }, \"Motivational Poems\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"the-will-to-win\",\n    \"title\": \"The Will to Win\"\n  }, \"the-will-to-win\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"invictus\",\n    \"title\": \"Invictus\"\n  }, \"invictus\"), \"]\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"472dc42c-92a7-5639-84ec-5227f9af8c38","fields":{"slug":"/misc/misc","title":"Miscellaneous"}}}]},"fields":{"slug":"/misc/sherlock-paper","title":"SherLock: Unsupervised Synchronization-Operation Inference"}}},"pageContext":{"id":"0d45807c-9a79-5866-ba09-56d5bceee0ec"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}