{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/st2131/recursive-binomial-coefficients","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"recursive-binomial-coefficients\"\n  }, \"Recursive Binomial Coefficients\"), mdx(\"h2\", {\n    \"id\": \"theorem\"\n  }, \"Theorem\"), mdx(\"p\", null, \"$$\\\\binom{n}{r} = \\\\binom{n-1}{r-1} + \\\\binom{n-1}{r}$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"h3\", {\n    \"id\": \"combinatorial-argument\"\n  }, \"Combinatorial Argument\"), mdx(\"p\", null, \"Sum of ways where some object is chosen and when it is not.\"), mdx(\"p\", null, \"If object 1 is chosen, then there are $\\\\binom{n -1}{r-1}$ ways of selecting $r-1$ objects from the remaining $n-1$ objects.\"), mdx(\"p\", null, \"If object 1 is not chosen, then there are $\\\\binom{n -1}{r}$ ways of selecting $r$ objects from the remaining $n-1$ objects.\"), mdx(\"p\", null, \"Thus, $\\\\binom{n}{r} = \\\\binom{n-1}{r-1} + \\\\binom{n-1}{r}$\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"combinatorial-analysis\"\n  }, \"Combinatorial Analysis\"), mdx(\"h2\", {\n    \"id\": \"principle-of-counting\"\n  }, \"Principle of Counting\"), mdx(\"p\", null, \"For independent events, the outcome space is the product of possible outcomes in each stage.\"), mdx(\"h2\", {\n    \"id\": \"permutations-of-arrangements\"\n  }, \"Permutations of Arrangements\"), mdx(\"p\", null, \"Arrangement of distinct objects:\\n$$n! = n \\\\times (n - 1) \\\\times (n - 2) \\\\times... \\\\times 2 \\\\times 1$$\"), mdx(\"h3\", {\n    \"id\": \"indistinguishable-elements\"\n  }, \"Indistinguishable Elements\"), mdx(\"p\", null, \"There are\\n$$\\\\frac{n!}{n_1! n_2! ... n_r!}$$\\ndifferent arrangements of $n$ objects, of which $n_i$ are alike\"), mdx(\"p\", null, \"Consider elements to be distinct, and remove the repeats.\"), mdx(\"h2\", {\n    \"id\": \"combinations\"\n  }, \"Combinations\"), mdx(\"p\", null, \"Number of ways of selecting a subset given a set.\\n$$\\\\binom{n}{r} = \\\\frac{n!}{(n-r)!r!}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Order is not important\")), mdx(\"h3\", {\n    \"id\": \"distinct-groups\"\n  }, \"Distinct Groups\"), mdx(\"p\", null, \"$$\\\\binom{n}{r_1, r_2, r_3, ...} = \\\\frac{n!}{r_1! r_2! r_3! ...}$$\"), mdx(\"p\", null, \"represents the number of possible divisions of $n$ \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"distinct\"), \" objects into $r$ \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"distinct\"), \" groups.\"), mdx(\"h4\", {\n    \"id\": \"sum-of-groups-constraint\"\n  }, \"Sum of Groups Constraint\"), mdx(\"p\", null, \"There are $\\\\binom{n-1}{r-1}$ distinct positive integer-valued vectors $(x_1, x_2, ..., x_r)$ satisfying\\n$$\\\\sum x_i = n$$\\n$$x_i > 0, \\\\forall i$$\"), mdx(\"p\", null, \"There are $\\\\binom{n+r-1}{r-1}$ distinct non-negative integer-valued vectors $(x_1, x_2, ..., x_r)$ satisfying\\n$$\\\\sum x_i = n$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"There can be 0\")), mdx(\"h3\", {\n    \"id\": \"notes\"\n  }, \"Notes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"recursive-binomial-coefficients\",\n    \"title\": \"Recursive Binomial Coefficients\"\n  }, \"recursive-binomial-coefficients\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"binomial-theorem\",\n    \"title\": \"Binomial Theorem\"\n  }, \"binomial-theorem\"), \"]\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"multinomial-theorem\",\n    \"title\": \"Multinomial Theorem\"\n  }, \"multinomial-theorem\"), \"]\")))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"6e347883-085f-52d7-869a-8cb5a9ac5540","fields":{"slug":"/st2131/combinatorial-analysis","title":"Combinatorial Analysis"}}}]},"fields":{"slug":"/st2131/recursive-binomial-coefficients","title":"Recursive Binomial Coefficients"}}},"pageContext":{"id":"2400e919-23bd-5e18-88e0-d3d5aa254ddd"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}