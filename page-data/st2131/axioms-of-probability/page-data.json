{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/st2131/axioms-of-probability","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"axioms-of-probability\"\n  }, \"Axioms of Probability\"), mdx(\"h2\", {\n    \"id\": \"preface\"\n  }, \"Preface\"), mdx(\"h3\", {\n    \"id\": \"sample-space\"\n  }, \"Sample Space\"), mdx(\"p\", null, \"Consider an experiment whose outcome is not predictable with certainty.\"), mdx(\"p\", null, \"The set of all possible outcomes of the experiment is known as the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"sample space\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Sample space can be uncountable (eg. age of a tree)\")), mdx(\"h3\", {\n    \"id\": \"event\"\n  }, \"Event\"), mdx(\"p\", null, \"Any subset of a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#sample-space\"\n  }, \"sample space\")), mdx(\"h3\", {\n    \"id\": \"laws-on-sets\"\n  }, \"Laws on Sets\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Commutative Laws\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Associative Laws\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Distributive Laws\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"De Morgan's Laws\")), mdx(\"h2\", {\n    \"id\": \"definition\"\n  }, \"Definition\"), mdx(\"p\", null, \"One way of defining the probability of an event is in terms of its \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"relative frequency\"), \":\"), mdx(\"p\", null, \"$$ P(E) = \\\\lim_{n \\\\rightarrow \\\\inf} \\\\frac{n(E)}{n} $$\"), mdx(\"h3\", {\n    \"id\": \"problems-with-this-definition\"\n  }, \"Problems with this definition:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"How do we know that $\\\\frac{n(E)}{n}$ will converge?\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"How do we know that $\\\\frac{n(E)}{n}$ will converge to the same if the experiment is repeatedly performed a second time?\")), mdx(\"h3\", {\n    \"id\": \"better-axioms\"\n  }, \"Better Axioms\"), mdx(\"p\", null, \"Consider an experiment whose sample space is $S$. For each event $E$ of the sample space $S$, we assume that a number $P(E)$ is defined and satisfies the following 3 [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"axiom\",\n    \"title\": \"Axiom\"\n  }, \"axiom\"), \"]s:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$0 \\\\leq P(E) \\\\leq 1$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$P(S) = 1$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"For any sequence of mutually exclusive events $E\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"1, E_2, ...$, $$P(\\\\bigcup^{\\\\infty}\"), \"{i = 1} E(i)) = \\\\sum^{\\\\infty}_{i = 1} P(E_i)$$\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The definitions of probability are mathematical definitions. They tell us which set functions can be called probability functions. They do not tell us the value of probability assigned to a given event.\")), mdx(\"h2\", {\n    \"id\": \"strong-law-of-large-numbers\"\n  }, \"Strong Law of Large Numbers\"), mdx(\"p\", null, \"If an experiment is repeated over and over again, then with probability 1, the proportion of time during which any specific event $E$ occurs will equal $P(E)$.\"), mdx(\"h2\", {\n    \"id\": \"inclusion-exclusion-identity\"\n  }, \"Inclusion-Exclusion Identity\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"inclusion-exclusion-identity\",\n    \"title\": \"Inclusion-Exclusion Identity\"\n  }, \"inclusion-exclusion-identity\"), \"]\"), mdx(\"h3\", {\n    \"id\": \"matching-hats-problem\"\n  }, \"Matching Hats Problem\"), mdx(\"p\", null, \"Suppose that each of $N$ men at a party throws his hat into the center of the room.\\nThe hats are first mized up, and then each man randomly selects a hat.\\nWhat is the probability that\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"none of the men selects his own hat\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"exactly $k$ of the men select their own hat\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Can also be expressed as a recursive equation.\")), mdx(\"h2\", {\n    \"id\": \"probability-as-a-continuous-set-function\"\n  }, \"Probability as a Continuous Set Function\"), mdx(\"p\", null, \"Suppose an increasing sequence of events:\"), mdx(\"p\", null, \"$$E_1 \\\\subset E_2 \\\\subset ... \\\\subset E_n \\\\subset ...$$\"), mdx(\"p\", null, \"Denote $\\\\lim\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{n \\\\rightarrow \\\\infty} E_n = \\\\bigcup^\\\\infty\"), \"{i = 1} E_i$\"), mdx(\"p\", null, \"$$E_1 \\\\supset E_2 \\\\supset ... \\\\supset E_n \\\\supset ...$$\"), mdx(\"p\", null, \"Denote $\\\\lim\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{n \\\\rightarrow \\\\infty} E_n = \\\\bigcap^\\\\infty\"), \"{i = 1} E_i$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"For increasing or decreasing sequence of events,\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$$\\\\lim\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{n \\\\rightarrow \\\\infty} P(E_n) = P(\\\\lim\"), \"{n \\\\rightarrow \\\\infty} E_n)$$\")), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"Set $F\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i = E_i - E\"), \"{i - 1}$\"), mdx(\"p\", null, \"Then union of $E$ is the same as sum of $F$ since $F$ is mutually exclusive.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"axiom\"\n  }, \"Axiom\"), mdx(\"h2\", {\n    \"id\": \"definition\"\n  }, \"Definition\"), mdx(\"p\", null, \"An axiom is a sentence or proposition that is taken for granted as true, and serves as a starting point for deducing other truths.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"3d82ec0f-fccb-5a89-a360-0d88eb677b8f","fields":{"slug":"/st2131/axiom","title":"Axiom"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"inclusion-exclusion-identity\"\n  }, \"Inclusion-Exclusion Identity\"), mdx(\"p\", null, \"Inclusion-Exclusion Identity:\"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\nP(E\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 \\\\cup E_2 \\\\cup ... \\\\cup E_n) &= \\\\sum^n\"), \"{i = 1} P(E\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i) \", \"\\\\\", \"\\n&- \\\\sum\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 < i_2} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2}) \", \"\\\\\", \"\\n&+ ... \", \"\\\\\", \"\\n&+ (-1)^{r + 1} \\\\sum\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 < i_2 < ... < i_r} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2}, ..., E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"r}) \", \"\\\\\", \"\\n&+ (-1)^{n + 1} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2}, ..., E\"), \"{i_n})\\n\\\\end{aligned}\\n$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"If an outcome of the sample space is not a member of any of the set $E\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i$, then its probability does not contribute anything to either side of the _addition law of exclusive events\"), \".\"), mdx(\"p\", null, \"Suppose that an outcome is in exactly $m$ of the events $E_i$, where $m > 0$,\\nand let the probability of the outcome be $w$, then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the outcome is in $E_1 \\\\cup E_2 \\\\cup ... \\\\cup E_n$ and $w$ will be counted once in $P(E_1 \\\\cup E_2 \\\\cup ... \\\\cup E_n)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the outcome is in exactly $m$ of the events and $w$ will be counted exactly $\\\\binom{m}{1}$ times in $\\\\sum^n_{i = 1} P(E_i)$.\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the outcome is contained in $\\\\binom{m}{2}$ subsets of the type $E\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{i_1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"2}$ and $w$ will be counted $\\\\binom{m}{2}$ times in $\\\\sum\"), \"{i\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"1 < i_2} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"1}, E\"), \"{i_2})$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"and so on.\")))), mdx(\"p\", null, \"Then \"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\nw &= \\\\binom{m}{1} w - \\\\binom{m}{2} w + \\\\binom{m}{3}w - ... \\\\plusmn \\\\binom{m}{m}w \", \"\\\\\", \"\\n1 &= \\\\binom{m}{1} - \\\\binom{m}{2} + \\\\binom{m}{3}- ... \\\\plusmn \\\\binom{m}{m} \", \"\\\\\", \"\\n&\\\\binom{m}{0} - \\\\binom{m}{1} + \\\\binom{m}{2} - \\\\binom{m}{3} + ... \\\\plusmn \\\\binom{m}{m} = 0\\n\\\\end{aligned}\\n$$\"), mdx(\"p\", null, \"$$\\n\\\\sum^m_{i = 0} \\\\binom{m}{i} (-1)^i = 0\\n$$\"), mdx(\"p\", null, \"Recall [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"binomial-theorem\",\n    \"title\": \"Binomial Theorem\"\n  }, \"binomial-theorem\"), \"],\"), mdx(\"p\", null, \"$$\\n\\\\sum^m_{i = 0} \\\\binom{m}{i} x^i y^{m - i} = (x + y)^{m}\\n$$\"), mdx(\"p\", null, \"Let $x = -1$, $y = 1$,\"), mdx(\"p\", null, \"$$\\n\\\\sum^m_{i = 0} \\\\binom{m}{i} (-1)^i = 0\\n$$\"), mdx(\"p\", null, \"Therefore \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#inclusion-exclusion-identity\"\n  }, \"the identity\"), \" is indeed true.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"bd2e3ebd-0d38-54ac-9ca9-51b482f3c5cb","fields":{"slug":"/st2131/inclusion-exclusion-identity","title":"Inclusion-Exclusion Identity"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"probability\"\n  }, \"Probability\"), mdx(\"p\", null, \"#entry\"), mdx(\"h2\", {\n    \"id\": \"module-information\"\n  }, \"Module Information\"), mdx(\"h3\", {\n    \"id\": \"assessment\"\n  }, \"Assessment\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Test\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Weightage\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"10x Online Quiz\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"30%\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Finals\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"70%\")))), mdx(\"h3\", {\n    \"id\": \"textbook\"\n  }, \"Textbook\"), mdx(\"p\", null, \"A First Course in Probability - Sheldon Ross\"), mdx(\"h2\", {\n    \"id\": \"table-of-contents\"\n  }, \"Table of Contents\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"combinatorial-analysis\",\n    \"title\": \"Combinatorial Analysis\"\n  }, \"combinatorial-analysis\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"axioms-of-probability\",\n    \"title\": \"Axioms of Probability\"\n  }, \"axioms-of-probability\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"conditional-probability-and-independence\",\n    \"title\": \"Conditional Probability and Independence\"\n  }, \"conditional-probability-and-independence\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"random-variables\",\n    \"title\": \"Random Variables\"\n  }, \"random-variables\"), \"]\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Jointly Distributed Random Variables\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Properties of Expectation\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Limit Theorems\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"76aa8a3f-23cf-5fb8-a593-9503686c3e01","fields":{"slug":"/st2131/module-2131","title":"Probability"}}}]},"fields":{"slug":"/st2131/axioms-of-probability","title":"Axioms of Probability"}}},"pageContext":{"id":"49f0af91-64c6-5e91-9c20-010d0dc1f658"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}