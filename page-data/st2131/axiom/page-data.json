{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/st2131/axiom","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"axiom\"\n  }, \"Axiom\"), mdx(\"h2\", {\n    \"id\": \"definition\"\n  }, \"Definition\"), mdx(\"p\", null, \"An axiom is a sentence or proposition that is taken for granted as true, and serves as a starting point for deducing other truths.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"axioms-of-probability\"\n  }, \"Axioms of Probability\"), mdx(\"h2\", {\n    \"id\": \"preface\"\n  }, \"Preface\"), mdx(\"h3\", {\n    \"id\": \"sample-space\"\n  }, \"Sample Space\"), mdx(\"p\", null, \"Consider an experiment whose outcome is not predictable with certainty.\"), mdx(\"p\", null, \"The set of all possible outcomes of the experiment is known as the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"sample space\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Sample space can be uncountable (eg. age of a tree)\")), mdx(\"h3\", {\n    \"id\": \"event\"\n  }, \"Event\"), mdx(\"p\", null, \"Any subset of a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#sample-space\"\n  }, \"sample space\")), mdx(\"h3\", {\n    \"id\": \"laws-on-sets\"\n  }, \"Laws on Sets\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Commutative Laws\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Associative Laws\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Distributive Laws\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"De Morgan's Laws\")), mdx(\"h2\", {\n    \"id\": \"definition\"\n  }, \"Definition\"), mdx(\"p\", null, \"One way of defining the probability of an event is in terms of its \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"relative frequency\"), \":\"), mdx(\"p\", null, \"$$ P(E) = \\\\lim_{n \\\\rightarrow \\\\inf} \\\\frac{n(E)}{n} $$\"), mdx(\"h3\", {\n    \"id\": \"problems-with-this-definition\"\n  }, \"Problems with this definition:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"How do we know that $\\\\frac{n(E)}{n}$ will converge?\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"How do we know that $\\\\frac{n(E)}{n}$ will converge to the same if the experiment is repeatedly performed a second time?\")), mdx(\"h3\", {\n    \"id\": \"better-axioms\"\n  }, \"Better Axioms\"), mdx(\"p\", null, \"Consider an experiment whose sample space is $S$. For each event $E$ of the sample space $S$, we assume that a number $P(E)$ is defined and satisfies the following 3 [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"axiom\",\n    \"title\": \"Axiom\"\n  }, \"axiom\"), \"]s:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$0 \\\\leq P(E) \\\\leq 1$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"$P(S) = 1$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"For any sequence of mutually exclusive events $E\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"1, E_2, ...$, $$P(\\\\bigcup^{\\\\infty}\"), \"{i = 1} E(i)) = \\\\sum^{\\\\infty}_{i = 1} P(E_i)$$\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The definitions of probability are mathematical definitions. They tell us which set functions can be called probability functions. They do not tell us the value of probability assigned to a given event.\")), mdx(\"h2\", {\n    \"id\": \"strong-law-of-large-numbers\"\n  }, \"Strong Law of Large Numbers\"), mdx(\"p\", null, \"If an experiment is repeated over and over again, then with probability 1, the proportion of time during which any specific event $E$ occurs will equal $P(E)$.\"), mdx(\"h2\", {\n    \"id\": \"inclusion-exclusion-identity\"\n  }, \"Inclusion-Exclusion Identity\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"inclusion-exclusion-identity\",\n    \"title\": \"Inclusion-Exclusion Identity\"\n  }, \"inclusion-exclusion-identity\"), \"]\"), mdx(\"h3\", {\n    \"id\": \"matching-hats-problem\"\n  }, \"Matching Hats Problem\"), mdx(\"p\", null, \"Suppose that each of $N$ men at a party throws his hat into the center of the room.\\nThe hats are first mized up, and then each man randomly selects a hat.\\nWhat is the probability that\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"none of the men selects his own hat\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"exactly $k$ of the men select their own hat\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Can also be expressed as a recursive equation.\")), mdx(\"h2\", {\n    \"id\": \"probability-as-a-continuous-set-function\"\n  }, \"Probability as a Continuous Set Function\"), mdx(\"p\", null, \"Suppose an increasing sequence of events:\"), mdx(\"p\", null, \"$$E_1 \\\\subset E_2 \\\\subset ... \\\\subset E_n \\\\subset ...$$\"), mdx(\"p\", null, \"Denote $\\\\lim\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{n \\\\rightarrow \\\\infty} E_n = \\\\bigcup^\\\\infty\"), \"{i = 1} E_i$\"), mdx(\"p\", null, \"$$E_1 \\\\supset E_2 \\\\supset ... \\\\supset E_n \\\\supset ...$$\"), mdx(\"p\", null, \"Denote $\\\\lim\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{n \\\\rightarrow \\\\infty} E_n = \\\\bigcap^\\\\infty\"), \"{i = 1} E_i$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"For increasing or decreasing sequence of events,\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$$\\\\lim\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{n \\\\rightarrow \\\\infty} P(E_n) = P(\\\\lim\"), \"{n \\\\rightarrow \\\\infty} E_n)$$\")), mdx(\"h3\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"Set $F\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i = E_i - E\"), \"{i - 1}$\"), mdx(\"p\", null, \"Then union of $E$ is the same as sum of $F$ since $F$ is mutually exclusive.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"49f0af91-64c6-5e91-9c20-010d0dc1f658","fields":{"slug":"/st2131/axioms-of-probability","title":"Axioms of Probability"}}}]},"fields":{"slug":"/st2131/axiom","title":"Axiom"}}},"pageContext":{"id":"3d82ec0f-fccb-5a89-a360-0d88eb677b8f"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}