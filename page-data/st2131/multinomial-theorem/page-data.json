{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/st2131/multinomial-theorem","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"multinomial-theorem\"\n  }, \"Multinomial Theorem\"), mdx(\"p\", null, \"Generalized [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"binomial-theorem\",\n    \"title\": \"Binomial Theorem\"\n  }, \"binomial-theorem\"), \"]\"), mdx(\"p\", null, \"$$(x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 + x_2 + x_3 +... + x_r)^n = \\\\sum\"), \"{n_1, n_2, n_3, ..., n_r} \\\\binom{n}{n_1, n_2, ..., n_r} x_1^{n_1} x_2^{n_2} ... x_r^{n_r} $$\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"binomial-theorem\"\n  }, \"Binomial Theorem\"), mdx(\"p\", null, \"$$(x + y)^n = \\\\sum^n_{k = 0} \\\\binom{n}{k} x^k y^{n - k}$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"By Mathematical Induction\"), mdx(\"h3\", {\n    \"id\": \"case-n--1\"\n  }, \"Case n = 1\"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\nLHS &= x + y \", \"\\\\\", \"\\nRHS &= \\\\binom{1}{0} y + \\\\binom{1}{1}x \", \"\\\\\", \"\\n\\\\therefore LHS &= RHS\\n\\\\end{aligned}\\n$$\"), mdx(\"h3\", {\n    \"id\": \"inductive-case\"\n  }, \"Inductive Case\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"h2\", {\n    \"id\": \"application\"\n  }, \"Application\"), mdx(\"p\", null, \"How many subsets are there of a set consisting of $n$ elements?\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$2^n$\")), mdx(\"p\", null, \"$$(1 + 1)^n = \\\\sum_{k=0}^{n} \\\\binom{n}{k} = \\\\text{number of ways to form subset of size k}$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"4bc32513-25c9-519b-ae00-7f6ea40189ee","fields":{"slug":"/st2131/binomial-theorem","title":"Binomial Theorem"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"combinatorial-analysis\"\n  }, \"Combinatorial Analysis\"), mdx(\"h2\", {\n    \"id\": \"principle-of-counting\"\n  }, \"Principle of Counting\"), mdx(\"p\", null, \"For independent events, the outcome space is the product of possible outcomes in each stage.\"), mdx(\"h2\", {\n    \"id\": \"permutations-of-arrangements\"\n  }, \"Permutations of Arrangements\"), mdx(\"p\", null, \"Arrangement of distinct objects:\\n$$n! = n \\\\times (n - 1) \\\\times (n - 2) \\\\times... \\\\times 2 \\\\times 1$$\"), mdx(\"h3\", {\n    \"id\": \"indistinguishable-elements\"\n  }, \"Indistinguishable Elements\"), mdx(\"p\", null, \"There are\\n$$\\\\frac{n!}{n_1! n_2! ... n_r!}$$\\ndifferent arrangements of $n$ objects, of which $n_i$ are alike\"), mdx(\"p\", null, \"Consider elements to be distinct, and remove the repeats.\"), mdx(\"h2\", {\n    \"id\": \"combinations\"\n  }, \"Combinations\"), mdx(\"p\", null, \"Number of ways of selecting a subset given a set.\\n$$\\\\binom{n}{r} = \\\\frac{n!}{(n-r)!r!}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Order is not important\")), mdx(\"h3\", {\n    \"id\": \"distinct-groups\"\n  }, \"Distinct Groups\"), mdx(\"p\", null, \"$$\\\\binom{n}{r_1, r_2, r_3, ...} = \\\\frac{n!}{r_1! r_2! r_3! ...}$$\"), mdx(\"p\", null, \"represents the number of possible divisions of $n$ \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"distinct\"), \" objects into $r$ \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"distinct\"), \" groups.\"), mdx(\"h4\", {\n    \"id\": \"sum-of-groups-constraint\"\n  }, \"Sum of Groups Constraint\"), mdx(\"p\", null, \"There are $\\\\binom{n-1}{r-1}$ distinct positive integer-valued vectors $(x_1, x_2, ..., x_r)$ satisfying\\n$$\\\\sum x_i = n$$\\n$$x_i > 0, \\\\forall i$$\"), mdx(\"p\", null, \"There are $\\\\binom{n+r-1}{r-1}$ distinct non-negative integer-valued vectors $(x_1, x_2, ..., x_r)$ satisfying\\n$$\\\\sum x_i = n$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"There can be 0\")), mdx(\"h3\", {\n    \"id\": \"notes\"\n  }, \"Notes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"recursive-binomial-coefficients\",\n    \"title\": \"Recursive Binomial Coefficients\"\n  }, \"recursive-binomial-coefficients\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"binomial-theorem\",\n    \"title\": \"Binomial Theorem\"\n  }, \"binomial-theorem\"), \"]\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"multinomial-theorem\",\n    \"title\": \"Multinomial Theorem\"\n  }, \"multinomial-theorem\"), \"]\")))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"6e347883-085f-52d7-869a-8cb5a9ac5540","fields":{"slug":"/st2131/combinatorial-analysis","title":"Combinatorial Analysis"}}}]},"fields":{"slug":"/st2131/multinomial-theorem","title":"Multinomial Theorem"}}},"pageContext":{"id":"7bad5acc-201d-56bb-ad30-142842abb408"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}