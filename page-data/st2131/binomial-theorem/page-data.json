{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/st2131/binomial-theorem","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"binomial-theorem\"\n  }, \"Binomial Theorem\"), mdx(\"p\", null, \"$$(x + y)^n = \\\\sum^n_{k = 0} \\\\binom{n}{k} x^k y^{n - k}$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"By Mathematical Induction\"), mdx(\"h3\", {\n    \"id\": \"case-n--1\"\n  }, \"Case n = 1\"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\nLHS &= x + y \", \"\\\\\", \"\\nRHS &= \\\\binom{1}{0} y + \\\\binom{1}{1}x \", \"\\\\\", \"\\n\\\\therefore LHS &= RHS\\n\\\\end{aligned}\\n$$\"), mdx(\"h3\", {\n    \"id\": \"inductive-case\"\n  }, \"Inductive Case\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../todo\",\n    \"title\": \"Todo\"\n  }, \"todo\"), \"]\"), mdx(\"h2\", {\n    \"id\": \"application\"\n  }, \"Application\"), mdx(\"p\", null, \"How many subsets are there of a set consisting of $n$ elements?\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"$2^n$\")), mdx(\"p\", null, \"$$(1 + 1)^n = \\\\sum_{k=0}^{n} \\\\binom{n}{k} = \\\\text{number of ways to form subset of size k}$$\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"todo\"\n  }, \"Todo\"), mdx(\"ul\", {\n    \"className\": \"contains-task-list\"\n  }, mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"Test Latex rendering\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"ibetchu-roadmap\",\n    \"title\": \"ibetchu Roadmap\"\n  }, \"ibetchu-roadmap\"), \"]\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"2e99ce11-4c41-5750-9b50-3a0077a4a8e3","fields":{"slug":"/todo","title":"Todo"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"inclusion-exclusion-identity\"\n  }, \"Inclusion-Exclusion Identity\"), mdx(\"p\", null, \"Inclusion-Exclusion Identity:\"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\nP(E\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 \\\\cup E_2 \\\\cup ... \\\\cup E_n) &= \\\\sum^n\"), \"{i = 1} P(E\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i) \", \"\\\\\", \"\\n&- \\\\sum\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 < i_2} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2}) \", \"\\\\\", \"\\n&+ ... \", \"\\\\\", \"\\n&+ (-1)^{r + 1} \\\\sum\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 < i_2 < ... < i_r} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2}, ..., E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"r}) \", \"\\\\\", \"\\n&+ (-1)^{n + 1} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2}, ..., E\"), \"{i_n})\\n\\\\end{aligned}\\n$$\"), mdx(\"h2\", {\n    \"id\": \"proof\"\n  }, \"Proof\"), mdx(\"p\", null, \"If an outcome of the sample space is not a member of any of the set $E\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i$, then its probability does not contribute anything to either side of the _addition law of exclusive events\"), \".\"), mdx(\"p\", null, \"Suppose that an outcome is in exactly $m$ of the events $E_i$, where $m > 0$,\\nand let the probability of the outcome be $w$, then\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the outcome is in $E_1 \\\\cup E_2 \\\\cup ... \\\\cup E_n$ and $w$ will be counted once in $P(E_1 \\\\cup E_2 \\\\cup ... \\\\cup E_n)$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the outcome is in exactly $m$ of the events and $w$ will be counted exactly $\\\\binom{m}{1}$ times in $\\\\sum^n_{i = 1} P(E_i)$.\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the outcome is contained in $\\\\binom{m}{2}$ subsets of the type $E\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"{i_1}, E\"), \"{i\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"2}$ and $w$ will be counted $\\\\binom{m}{2}$ times in $\\\\sum\"), \"{i\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"1 < i_2} P(E\"), \"{i\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"1}, E\"), \"{i_2})$\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"and so on.\")))), mdx(\"p\", null, \"Then \"), mdx(\"p\", null, \"$$\\n\\\\begin{aligned}\\nw &= \\\\binom{m}{1} w - \\\\binom{m}{2} w + \\\\binom{m}{3}w - ... \\\\plusmn \\\\binom{m}{m}w \", \"\\\\\", \"\\n1 &= \\\\binom{m}{1} - \\\\binom{m}{2} + \\\\binom{m}{3}- ... \\\\plusmn \\\\binom{m}{m} \", \"\\\\\", \"\\n&\\\\binom{m}{0} - \\\\binom{m}{1} + \\\\binom{m}{2} - \\\\binom{m}{3} + ... \\\\plusmn \\\\binom{m}{m} = 0\\n\\\\end{aligned}\\n$$\"), mdx(\"p\", null, \"$$\\n\\\\sum^m_{i = 0} \\\\binom{m}{i} (-1)^i = 0\\n$$\"), mdx(\"p\", null, \"Recall [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"binomial-theorem\",\n    \"title\": \"Binomial Theorem\"\n  }, \"binomial-theorem\"), \"],\"), mdx(\"p\", null, \"$$\\n\\\\sum^m_{i = 0} \\\\binom{m}{i} x^i y^{m - i} = (x + y)^{m}\\n$$\"), mdx(\"p\", null, \"Let $x = -1$, $y = 1$,\"), mdx(\"p\", null, \"$$\\n\\\\sum^m_{i = 0} \\\\binom{m}{i} (-1)^i = 0\\n$$\"), mdx(\"p\", null, \"Therefore \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#inclusion-exclusion-identity\"\n  }, \"the identity\"), \" is indeed true.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"bd2e3ebd-0d38-54ac-9ca9-51b482f3c5cb","fields":{"slug":"/st2131/inclusion-exclusion-identity","title":"Inclusion-Exclusion Identity"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"multinomial-theorem\"\n  }, \"Multinomial Theorem\"), mdx(\"p\", null, \"Generalized [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"binomial-theorem\",\n    \"title\": \"Binomial Theorem\"\n  }, \"binomial-theorem\"), \"]\"), mdx(\"p\", null, \"$$(x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 + x_2 + x_3 +... + x_r)^n = \\\\sum\"), \"{n_1, n_2, n_3, ..., n_r} \\\\binom{n}{n_1, n_2, ..., n_r} x_1^{n_1} x_2^{n_2} ... x_r^{n_r} $$\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"7bad5acc-201d-56bb-ad30-142842abb408","fields":{"slug":"/st2131/multinomial-theorem","title":"Multinomial Theorem"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"combinatorial-analysis\"\n  }, \"Combinatorial Analysis\"), mdx(\"h2\", {\n    \"id\": \"principle-of-counting\"\n  }, \"Principle of Counting\"), mdx(\"p\", null, \"For independent events, the outcome space is the product of possible outcomes in each stage.\"), mdx(\"h2\", {\n    \"id\": \"permutations-of-arrangements\"\n  }, \"Permutations of Arrangements\"), mdx(\"p\", null, \"Arrangement of distinct objects:\\n$$n! = n \\\\times (n - 1) \\\\times (n - 2) \\\\times... \\\\times 2 \\\\times 1$$\"), mdx(\"h3\", {\n    \"id\": \"indistinguishable-elements\"\n  }, \"Indistinguishable Elements\"), mdx(\"p\", null, \"There are\\n$$\\\\frac{n!}{n_1! n_2! ... n_r!}$$\\ndifferent arrangements of $n$ objects, of which $n_i$ are alike\"), mdx(\"p\", null, \"Consider elements to be distinct, and remove the repeats.\"), mdx(\"h2\", {\n    \"id\": \"combinations\"\n  }, \"Combinations\"), mdx(\"p\", null, \"Number of ways of selecting a subset given a set.\\n$$\\\\binom{n}{r} = \\\\frac{n!}{(n-r)!r!}$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Order is not important\")), mdx(\"h3\", {\n    \"id\": \"distinct-groups\"\n  }, \"Distinct Groups\"), mdx(\"p\", null, \"$$\\\\binom{n}{r_1, r_2, r_3, ...} = \\\\frac{n!}{r_1! r_2! r_3! ...}$$\"), mdx(\"p\", null, \"represents the number of possible divisions of $n$ \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"distinct\"), \" objects into $r$ \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"distinct\"), \" groups.\"), mdx(\"h4\", {\n    \"id\": \"sum-of-groups-constraint\"\n  }, \"Sum of Groups Constraint\"), mdx(\"p\", null, \"There are $\\\\binom{n-1}{r-1}$ distinct positive integer-valued vectors $(x_1, x_2, ..., x_r)$ satisfying\\n$$\\\\sum x_i = n$$\\n$$x_i > 0, \\\\forall i$$\"), mdx(\"p\", null, \"There are $\\\\binom{n+r-1}{r-1}$ distinct non-negative integer-valued vectors $(x_1, x_2, ..., x_r)$ satisfying\\n$$\\\\sum x_i = n$$\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"There can be 0\")), mdx(\"h3\", {\n    \"id\": \"notes\"\n  }, \"Notes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"recursive-binomial-coefficients\",\n    \"title\": \"Recursive Binomial Coefficients\"\n  }, \"recursive-binomial-coefficients\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"binomial-theorem\",\n    \"title\": \"Binomial Theorem\"\n  }, \"binomial-theorem\"), \"]\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"multinomial-theorem\",\n    \"title\": \"Multinomial Theorem\"\n  }, \"multinomial-theorem\"), \"]\")))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"6e347883-085f-52d7-869a-8cb5a9ac5540","fields":{"slug":"/st2131/combinatorial-analysis","title":"Combinatorial Analysis"}}}]},"fields":{"slug":"/st2131/binomial-theorem","title":"Binomial Theorem"}}},"pageContext":{"id":"4bc32513-25c9-519b-ae00-7f6ea40189ee"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}